package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"meditrax/graph/chat"
	"meditrax/graph/model"
	"strconv"
	"strings"
)

// GetFoodSpecs is the resolver for the getFoodSpecs field.
func (r *queryResolver) GetFoodSpecs(ctx context.Context, food string) (*model.FoodSpecs, error) {
	client := chat.GetClient()

	result, err := chat.GetFoodSpec(food, client)
	if err != nil {
		return nil, err
	}

	println(*result)

	lines := strings.Split(*result, "\n")

	var specs []*model.FoodSpec
	var n_spec = 0.0
	var s_total = 0.0
	for _, line := range lines {
		line = strings.TrimSpace(line)

		parameters := strings.Split(line, ": ")
		info := strings.Split(strings.TrimSpace(parameters[1]), " ")

		println(parameters[0] + parameters[1])
		println(info[0])

		value, err := strconv.ParseFloat(info[0], 32)
		if err != nil {
			continue
		}

		spec := &model.FoodSpec{
			Name:  parameters[0],
			Value: value,
			Unit:  info[1],
		}

		var valid_spec = false
		for _, spec_limit := range chat.SpecLimits {
			if spec.Name == spec_limit.Name {
				valid_spec = true

				spec.HowHigh = min(1, value/spec_limit.UpperRange)
				n_spec = n_spec + 1
				s_total = s_total + value/spec_limit.UpperRange
				// if value > spec_limit.UpperRange {
				// 	spec.IsTooHigh = true
				// 	recommend = false
				// } else {
				// 	spec.IsTooHigh = false
				// }
			}
		}

		if valid_spec {
			specs = append(specs, spec)
		}
	}

	foodSpecs := &model.FoodSpecs{
		Specs:        specs,
		HowRecommend: min(1, s_total/n_spec),
	}

	return foodSpecs, nil
}

// GetMockFoodSepcs is the resolver for the getMockFoodSepcs field.
func (r *queryResolver) GetMockFoodSepcs(ctx context.Context, food string) (*model.FoodSpecs, error) {
	var specs []*model.FoodSpec
	for _, spec_limit := range chat.SpecLimits {
		specs = append(specs, &model.FoodSpec{Name: spec_limit.Name, Value: spec_limit.UpperRange / 2})
	}

	foodSpecs := &model.FoodSpecs{
		Specs:        specs,
		HowRecommend: 0.5,
	}

	return foodSpecs, nil
}
