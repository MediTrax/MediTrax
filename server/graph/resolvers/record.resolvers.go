package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/database"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"
	"meditrax/graph/utils"
	"strings"

	surrealdb "github.com/surrealdb/surrealdb.go"
)

// AddHealthMetric is the resolver for the addHealthMetric field.
func (r *mutationResolver) AddHealthMetric(ctx context.Context, metricType string, value float64, unit string, recordedAt string) (*model.AddHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check that there isn't already a metric entry for the user with the same type and record time
	result, err := database.DB.Query(
		`SELECT * FROM health_metric WHERE user_id=$user_id AND recorded_at=$recordedAt AND metric_type=$metricType;`,
		map[string]interface{}{
			"user_id":    user.ID,
			"recordedAt": recordedAt,
			"metricType": metricType,
		},
	)
	if err != nil {
		return nil, err
	}
	metrics, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(metrics) > 0 {
		return nil, fmt.Errorf("health metric with the same type and same recordAt time already exists")
	}

	// create new HealthMetric record
	result, err = database.DB.Query(
		`CREATE ONLY health_metric:ulid()
		SET
		user_id=$user_id,
		metric_type=$metric_type,
		value=$value,
		unit=$unit,
		recorded_at=$recorded_at,
		created_at=time::now();
		`,
		map[string]interface{}{
			"user_id":     user.ID,
			"metric_type": metricType,
			"value":       value,
			"unit":        unit,
			"recorded_at": recordedAt,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshall the returned results
	newMetric, err := surrealdb.SmartUnmarshal[model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	response := &model.AddHealthMetricResponse{
		MetricID: newMetric.ID,
		Message:  "new health metric added successfully",
	}

	return response, nil
}

// UpdateHealthMetric is the resolver for the updateHealthMetric field.
func (r *mutationResolver) UpdateHealthMetric(ctx context.Context, metricID string, value *float64, unit *string) (*model.UpdateHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check legality of the health metric id
	if !utils.MatchID(metricID, "health_metric") {
		return nil, fmt.Errorf("illegal health metric id")
	}

	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": metricID, "user_id": user.ID}

	// Prepare the fields to be updated
	updateFields := []string{}
	if value != nil {
		updateValues["value"] = *value
		updateFields = append(updateFields, "value = $value")
	}
	if unit != nil {
		updateValues["unit"] = *unit
		updateFields = append(updateFields, "unit = $unit")
	}

	// write to the query
	query := fmt.Sprintf("UPDATE $id SET %s WHERE user_id=$user_id;", strings.Join(updateFields, ", "))
	// send the UPDATE query
	result, err := database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// unmarshal results
	results, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no user associated heath metric object found")
	}

	response := &model.UpdateHealthMetricResponse{
		MetricID: results[0].ID,
		Message:  "Health metric updated successfully",
	}

	return response, nil
}

// DeleteHealthMetric is the resolver for the deleteHealthMetric field.
func (r *mutationResolver) DeleteHealthMetric(ctx context.Context, metricID string) (*model.DeleteHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check the legality of the metric id
	if !utils.MatchID(metricID, "health_metric") {
		return nil, fmt.Errorf("illegal health metric id")
	}

	// Execute the query, returning the entry before it is deleted
	result, err := database.DB.Query(
		`DELETE $id WHERE user_id=$user_id RETURN BEFORE;`,
		map[string]interface{}{
			"id":      metricID,
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshal the results, and check if the entry existed before DELETE
	results, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no health metric object found")
	}

	// create response
	response := &model.DeleteHealthMetricResponse{
		Message: fmt.Sprintf("Health metric %s of type %s deleted successfully", results[0].ID, results[0].MetricType),
	}

	return response, nil
}

// AddMedicalRecord is the resolver for the addMedicalRecord field.
func (r *mutationResolver) AddMedicalRecord(ctx context.Context, recordType string, content string) (*model.AddMedicalRecordResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 插入新的医疗记录
	result, err := database.DB.Query(
		`CREATE ONLY medical_record:ulid() 
        SET user_id=$user_id,
			record_type=$recordType,
            content=$content,
            created_at=time::now(),
            updated_at=time::now();`,
		map[string]interface{}{
			"user_id":    user.ID,
			"recordType": recordType,
			"content":    content,
		},
	)
	if err != nil {
		return nil, err
	}

	newRecord, err := surrealdb.SmartUnmarshal[model.MedicalRecord](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.AddMedicalRecordResponse{
		RecordID: newRecord.ID,
		Message:  "Medical record added successfully",
	}

	return response, nil
}

// UpdateMedicalRecord is the resolver for the updateMedicalRecord field.
// UpdateMedicalRecord is the resolver for the updateMedicalRecord field.
func (r *mutationResolver) UpdateMedicalRecord(ctx context.Context, recordID string, recordType *string, content *string) (*model.UpdateMedicalRecordResponse, error) {
	// Check if the user is logged in correctly
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// Check if the record ID is valid
	if !utils.MatchID(recordID, "medical_record") {
		return nil, fmt.Errorf("illegal record id")
	}

	// Initialize the map to hold update values
	updateValues := map[string]interface{}{"id": recordID, "user_id": user.ID}

	// Prepare the fields to be updated
	updateFields := []string{"updated_at = time::now()"} // Always update the updated_at field
	if recordType != nil {
		updateValues["recordType"] = *recordType
		updateFields = append(updateFields, "recordType = $recordType")
	}
	if content != nil {
		updateValues["content"] = *content
		updateFields = append(updateFields, "content = $content")
	}

	// Construct the final query
	query := fmt.Sprintf("UPDATE medical_record SET %s WHERE id=$id AND user_id=$user_id;", strings.Join(updateFields, ", "))

	// Execute the update query
	_, err := database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// Prepare the response
	response := &model.UpdateMedicalRecordResponse{
		RecordID: recordID,
		Message:  "Medical record updated successfully",
	}

	// Return the response with the record ID and success message
	return response, nil
}

// DeleteMedicalRecord is the resolver for the deleteMedicalRecord field.
func (r *mutationResolver) DeleteMedicalRecord(ctx context.Context, recordID string) (*model.DeleteMedicalRecordResponse, error) {
	//panic(fmt.Errorf("not implemented: DeleteMedicalRecord - deleteMedicalRecord"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 执行删除
	_, err := database.DB.Query(`DELETE FROM medical_record WHERE id=$id;`, map[string]interface{}{
		"id": recordID,
	})
	if err != nil {
		return nil, err
	}

	response := &model.DeleteMedicalRecordResponse{
		Message: "Medical record deleted successfully",
	}

	return response, nil
}

// GetHealthMetrics is the resolver for the getHealthMetrics field.
func (r *queryResolver) GetHealthMetrics(ctx context.Context, startDate *string, endDate *string, metricType *string) ([]*model.HealthMetricDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	var result interface{}
	var err error

	// get all the health metric entries that is associated with the user
	if metricType == nil {
		result, err = database.DB.Query(
			`SELECT * FROM health_metric WHERE user_id = $user_id;`,
			map[string]interface{}{
				"user_id": user.ID,
			},
		)
	} else {
		result, err = database.DB.Query(
			`SELECT * FROM health_metric WHERE user_id = $user_id AND metric_type=$metric_type;`,
			map[string]interface{}{
				"user_id":     user.ID,
				"metric_type": *metricType,
			},
		)
	}

	if err != nil {
		return nil, err
	}

	// unmarshal results into Go objects
	metrics, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}

	// loop through the metrics, convert them into HealthMetricDetail, then return the converted list and nil
	var metricDetails []*model.HealthMetricDetail
	for _, metric := range metrics {
		// check that the metric is within the record time constraints
		if !((startDate != nil && metric.RecordedAt < *startDate) || (endDate != nil && metric.RecordedAt > *endDate)) {
			metricDetail := &model.HealthMetricDetail{
				MetricID:   metric.ID,
				MetricType: metric.MetricType,
				Value:      metric.Value,
				RecordedAt: metric.RecordedAt,
				Unit:       metric.Unit,
			}
			metricDetails = append(metricDetails, metricDetail)
		}
	}

	return metricDetails, nil
}

// GetMedicalRecords is the resolver for the getMedicalRecords field.
func (r *queryResolver) GetMedicalRecords(ctx context.Context) ([]*model.MedicalRecordDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// Fetch treatment schedules for the user
	result, err := database.DB.Query(`SELECT * FROM medical_record WHERE user_id=$userID;`, map[string]interface{}{
		"userID": user.ID,
	})
	if err != nil {
		return nil, err
	}

	// TODO: please modify this line as it may result in a bug
	records, err := surrealdb.SmartUnmarshal[[]*model.MedicalRecord](result, nil)
	if err != nil {
		return nil, err
	}

	var record_details []*model.MedicalRecordDetail
	for _, record := range records {
		recordDetail := &model.MedicalRecordDetail{
			RecordID:   record.ID,
			RecordType: record.RecordType,
			Content:    record.Content,
			CreatedAt:  record.CreatedAt,
		}
		record_details = append(record_details, recordDetail)
	}

	return record_details, nil
}
