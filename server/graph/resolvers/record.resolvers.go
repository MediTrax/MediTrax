package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/database"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"
	"meditrax/graph/utils"
	"strings"

	surrealdb "github.com/surrealdb/surrealdb.go"
)

// AddHealthMetric is the resolver for the addHealthMetric field.
func (r *mutationResolver) AddHealthMetric(ctx context.Context, metricType string, value float64, unit string, recordedAt string) (*model.AddHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check that there isn't already a metric entry for the user with the same type and record time
	result, err := database.DB.Query(
		`SELECT * FROM health_metric WHERE user_id=$user_id AND recorded_at=$recordedAt AND metric_type=$metricType;`,
		map[string]interface{}{
			"user_id":    user.ID,
			"recordedAt": recordedAt,
			"metricType": metricType,
		},
	)
	if err != nil {
		return nil, err
	}
	metrics, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(metrics) > 0 {
		return nil, fmt.Errorf("health metric with the same type and same recordAt time already exists")
	}

	// create new HealthMetric record
	result, err = database.DB.Query(
		`CREATE ONLY health_metric:ulid()
		SET
		user_id=$user_id,
		metric_type=$metric_type,
		value=$value,
		unit=$unit,
		recorded_at=$recorded_at,
		created_at=time::now();
		`,
		map[string]interface{}{
			"user_id":     user.ID,
			"metric_type": metricType,
			"value":       value,
			"unit":        unit,
			"recorded_at": recordedAt,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshall the returned results
	newMetric, err := surrealdb.SmartUnmarshal[model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	response := &model.AddHealthMetricResponse{
		MetricID: newMetric.ID,
		Message:  "new health metric added successfully",
	}

	return response, nil
}

// UpdateHealthMetric is the resolver for the updateHealthMetric field.
func (r *mutationResolver) UpdateHealthMetric(ctx context.Context, metricID string, value *float64, unit *string) (*model.UpdateHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check legality of the health metric id
	if !utils.MatchID(metricID, "health_metric") {
		return nil, fmt.Errorf("illegal health metric id")
	}

	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": metricID, "user_id": user.ID}

	// Prepare the fields to be updated
	updateFields := []string{}
	if value != nil {
		updateValues["value"] = *value
		updateFields = append(updateFields, "value = $value")
	}
	if unit != nil {
		updateValues["unit"] = *unit
		updateFields = append(updateFields, "unit = $unit")
	}

	// write to the query
	query := fmt.Sprintf("UPDATE $id SET %s WHERE user_id=$user_id;", strings.Join(updateFields, ", "))
	// send the UPDATE query
	result, err := database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// unmarshal results
	results, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no user associated heath metric object found")
	}

	response := &model.UpdateHealthMetricResponse{
		MetricID: results[0].ID,
		Message:  "Health metric updated successfully",
	}

	return response, nil
}

// DeleteHealthMetric is the resolver for the deleteHealthMetric field.
func (r *mutationResolver) DeleteHealthMetric(ctx context.Context, metricID string) (*model.DeleteHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check the legality of the metric id
	if !utils.MatchID(metricID, "health_metric") {
		return nil, fmt.Errorf("illegal health metric id")
	}

	// Execute the query, returning the entry before it is deleted
	result, err := database.DB.Query(
		`DELETE $id WHERE user_id=$user_id RETURN BEFORE;`,
		map[string]interface{}{
			"id":      metricID,
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshal the results, and check if the entry existed before DELETE
	results, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no health metric object found")
	}

	// create response
	response := &model.DeleteHealthMetricResponse{
		Message: fmt.Sprintf("Health metric %s of type %s deleted successfully", results[0].ID, results[0].MetricType),
	}

	return response, nil
}

// AddMedicalRecord is the resolver for the addMedicalRecord field.
func (r *mutationResolver) AddMedicalRecord(ctx context.Context, recordType string, content string) (*model.AddMedicalRecordResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 插入新的医疗记录
	result, err := database.DB.Query(
		`CREATE ONLY medical_record:ulid() 
        SET user_id=$user_id,
			record_type=$recordType,
            content=$content,
            created_at=time::now(),
            updated_at=time::now();`,
		map[string]interface{}{
			"user_id":    user.ID,
			"recordType": recordType,
			"content":    content,
		},
	)
	if err != nil {
		return nil, err
	}

	newRecord, err := surrealdb.SmartUnmarshal[model.MedicalRecord](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.AddMedicalRecordResponse{
		RecordID: newRecord.ID,
		Message:  "Medical record added successfully",
	}

	return response, nil
}

// UpdateMedicalRecord is the resolver for the updateMedicalRecord field.
func (r *mutationResolver) UpdateMedicalRecord(ctx context.Context, recordID string, recordType *string, content *string) (*model.UpdateMedicalRecordResponse, error) {
	panic(fmt.Errorf("not implemented: UpdateMedicalRecord - updateMedicalRecord"))
}

// DeleteMedicalRecord is the resolver for the deleteMedicalRecord field.
func (r *mutationResolver) DeleteMedicalRecord(ctx context.Context, recordID string) (*model.DeleteMedicalRecordResponse, error) {
	panic(fmt.Errorf("not implemented: DeleteMedicalRecord - deleteMedicalRecord"))
}

// GetHealthMetrics is the resolver for the getHealthMetrics field.
func (r *queryResolver) GetHealthMetrics(ctx context.Context, startDate *string, endDate *string, metricType *string) ([]*model.HealthMetricDetail, error) {
	panic(fmt.Errorf("not implemented: GetHealthMetrics - getHealthMetrics"))
}

// GetMedicalRecords is the resolver for the getMedicalRecords field.
func (r *queryResolver) GetMedicalRecords(ctx context.Context) ([]*model.MedicalRecordDetail, error) {
	panic(fmt.Errorf("not implemented: GetMedicalRecords - getMedicalRecords"))
}
