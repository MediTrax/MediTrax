package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/database"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"
	"meditrax/graph/utils"
	"strings"

	surrealdb "github.com/surrealdb/surrealdb.go"
)

// AddHealthMetric is the resolver for the addHealthMetric field.
func (r *mutationResolver) AddHealthMetric(ctx context.Context, metricType string, value float64, unit string, recordedAt string) (*model.AddHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check that there isn't already a metric entry for the user with the same type and record time
	result, err := database.DB.Query(
<<<<<<< HEAD
		`SELECT * FROM health_metric WHERE user_id=$user_id AND recorded_at=$recordedAt AND metric_type=$metricType;`,
		map[string]interface{}{
			"user_id":    user.ID,
=======
		`SELECT * FROM health_metric WHERE userId=$userId AND recordedAt=$recordedAt AND metricType=$metricType;`,
		map[string]interface{}{
			"userId":     user.ID,
>>>>>>> 01096166741546756a9456fc584388602358902c
			"recordedAt": recordedAt,
			"metricType": metricType,
		},
	)
	if err != nil {
		return nil, err
	}
	metrics, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(metrics) > 0 {
		return nil, fmt.Errorf("health metric with the same type and same recordAt time already exists")
	}

	// create new HealthMetric record
	result, err = database.DB.Query(
		`CREATE ONLY health_metric:ulid()
		SET
<<<<<<< HEAD
		user_id=$user_id,
		metric_type=$metric_type,
		value=$value,
		unit=$unit,
		recorded_at=$recorded_at,
		created_at=time::now();
		`,
		map[string]interface{}{
			"user_id":     user.ID,
			"metric_type": metricType,
			"value":       value,
			"unit":        unit,
			"recorded_at": recordedAt,
=======
		userId=$userId,
		metricType=$metricType,
		value=$value,
		unit=$unit,
		recordedAt=$recordedAt,
		createdAt=time::now();
		`,
		map[string]interface{}{
			"userId":     user.ID,
			"metricType": metricType,
			"value":      value,
			"unit":       unit,
			"recordedAt": recordedAt,
>>>>>>> 01096166741546756a9456fc584388602358902c
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshall the returned results
	newMetric, err := surrealdb.SmartUnmarshal[model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	response := &model.AddHealthMetricResponse{
		MetricID: newMetric.ID,
		Message:  "new health metric added successfully",
	}

	return response, nil
}

// UpdateHealthMetric is the resolver for the updateHealthMetric field.
func (r *mutationResolver) UpdateHealthMetric(ctx context.Context, metricID string, value *float64, unit *string) (*model.UpdateHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check legality of the health metric id
	if !utils.MatchID(metricID, "health_metric") {
		return nil, fmt.Errorf("illegal health metric id")
	}

<<<<<<< HEAD
	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": metricID, "user_id": user.ID}
=======
	result, err := database.DB.Query(
		`SELECT * FROM ONLY $metricId WHERE userId=$userId;`,
		map[string]interface{}{
			"metricId": metricID,
			"userId":   user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	original, err := surrealdb.SmartUnmarshal[model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}

	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": metricID, "userId": user.ID}

	var changeLog []utils.ChangeLog
>>>>>>> 01096166741546756a9456fc584388602358902c

	// Prepare the fields to be updated
	updateFields := []string{}
	if value != nil {
		updateValues["value"] = *value
		updateFields = append(updateFields, "value = $value")
<<<<<<< HEAD
=======
		change := utils.ChangeLog{
			Field: "value",
			From:  fmt.Sprintf("%f", original.Value),
			To:    fmt.Sprintf("%f", *value),
		}
		changeLog = append(changeLog, change)
>>>>>>> 01096166741546756a9456fc584388602358902c
	}
	if unit != nil {
		updateValues["unit"] = *unit
		updateFields = append(updateFields, "unit = $unit")
<<<<<<< HEAD
	}

	// write to the query
	query := fmt.Sprintf("UPDATE $id SET %s WHERE user_id=$user_id;", strings.Join(updateFields, ", "))
	// send the UPDATE query
	result, err := database.DB.Query(query, updateValues)
=======
		change := utils.ChangeLog{
			Field: "unit",
			From:  original.Unit,
			To:    *unit,
		}
		changeLog = append(changeLog, change)
	}

	// write to the query
	query := fmt.Sprintf("UPDATE $id SET %s WHERE userId=$userId;", strings.Join(updateFields, ", "))
	// send the UPDATE query
	result, err = database.DB.Query(query, updateValues)
>>>>>>> 01096166741546756a9456fc584388602358902c
	if err != nil {
		return nil, err
	}

	// unmarshal results
	results, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no user associated heath metric object found")
	}

<<<<<<< HEAD
=======
	// add to activity log
	err = utils.AddActivityLogs(user.ID, "updateHealthMetric", "user updated specs of a health metric", metricID, changeLog)
	if err != nil {
		return nil, err
	}

>>>>>>> 01096166741546756a9456fc584388602358902c
	response := &model.UpdateHealthMetricResponse{
		MetricID: results[0].ID,
		Message:  "Health metric updated successfully",
	}

	return response, nil
}

// DeleteHealthMetric is the resolver for the deleteHealthMetric field.
func (r *mutationResolver) DeleteHealthMetric(ctx context.Context, metricID string) (*model.DeleteHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check the legality of the metric id
	if !utils.MatchID(metricID, "health_metric") {
		return nil, fmt.Errorf("illegal health metric id")
	}

	// Execute the query, returning the entry before it is deleted
	result, err := database.DB.Query(
<<<<<<< HEAD
		`DELETE $id WHERE user_id=$user_id RETURN BEFORE;`,
		map[string]interface{}{
			"id":      metricID,
			"user_id": user.ID,
=======
		`DELETE $id WHERE userId=$userId RETURN BEFORE;`,
		map[string]interface{}{
			"id":     metricID,
			"userId": user.ID,
>>>>>>> 01096166741546756a9456fc584388602358902c
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshal the results, and check if the entry existed before DELETE
	results, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no health metric object found")
	}

	// create response
	response := &model.DeleteHealthMetricResponse{
		Message: fmt.Sprintf("Health metric %s of type %s deleted successfully", results[0].ID, results[0].MetricType),
	}

	return response, nil
}

// AddMedicalRecord is the resolver for the addMedicalRecord field.
func (r *mutationResolver) AddMedicalRecord(ctx context.Context, recordType string, content string) (*model.AddMedicalRecordResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 插入新的医疗记录
	result, err := database.DB.Query(
		`CREATE ONLY medical_record:ulid() 
<<<<<<< HEAD
        SET user_id=$user_id,
			record_type=$recordType,
=======
        SET userId=$userId,
			recordType=$recordType,
>>>>>>> 01096166741546756a9456fc584388602358902c
            content=$content,
            createdAt=time::now(),
            updatedAt=time::now();`,
		map[string]interface{}{
<<<<<<< HEAD
			"user_id":    user.ID,
=======
			"userId":     user.ID,
>>>>>>> 01096166741546756a9456fc584388602358902c
			"recordType": recordType,
			"content":    content,
		},
	)
	if err != nil {
		return nil, err
	}

	newRecord, err := surrealdb.SmartUnmarshal[model.MedicalRecord](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.AddMedicalRecordResponse{
		RecordID: newRecord.ID,
		Message:  "Medical record added successfully",
	}

	return response, nil
}

// UpdateMedicalRecord is the resolver for the updateMedicalRecord field.
func (r *mutationResolver) UpdateMedicalRecord(ctx context.Context, recordID string, recordType *string, content *string) (*model.UpdateMedicalRecordResponse, error) {
	//panic(fmt.Errorf("not implemented: UpdateMedicalRecord - updateMedicalRecord"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
<<<<<<< HEAD
	// 构建更新查询
	query := `UPDATE medical_record SET updatedAt=time::now()`
	params := map[string]interface{}{}

	if recordType != nil {
		query += `, recordType=$recordType`
		params["recordType"] = *recordType
	}
	if content != nil {
		query += `, content=$content`
		params["content"] = *content
	}
	query += ` WHERE id=$id;`
	params["id"] = recordID

	// 执行更新
	_, err := database.DB.Query(query, params)
=======
	// check legality of the health metric id
	if !utils.MatchID(recordID, "medical_record") {
		return nil, fmt.Errorf("illegal medical record id")
	}

	result, err := database.DB.Query(
		`SELECT * FROM ONLY $recordId WHERE userId=$userId;`,
		map[string]interface{}{
			"recordId": recordID,
			"userId":   user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	original, err := surrealdb.SmartUnmarshal[model.MedicalRecord](result, nil)
	if err != nil {
		return nil, err
	}

	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": recordID, "userId": user.ID}

	var changeLog []utils.ChangeLog

	// Prepare the fields to be updated
	updateFields := []string{}
	if recordType != nil {
		updateValues["recordType"] = *recordType
		updateFields = append(updateFields, "recordType = $recordType")
		change := utils.ChangeLog{
			Field: "recordType",
			From:  original.RecordType,
			To:    *recordType,
		}
		changeLog = append(changeLog, change)
	}
	if content != nil {
		updateValues["content"] = *content
		updateFields = append(updateFields, "content = $content")
		change := utils.ChangeLog{
			Field: "content",
			From:  original.Content,
			To:    *content,
		}
		changeLog = append(changeLog, change)
	}

	// write to the query
	query := fmt.Sprintf("UPDATE $id SET %s WHERE userId=$userId;", strings.Join(updateFields, ", "))
	// send the UPDATE query
	result, err = database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// unmarshal results
	results, err := surrealdb.SmartUnmarshal[[]model.MedicalRecord](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no user associated medical record object found")
	}

	// add to activity log
	err = utils.AddActivityLogs(user.ID, "updateMedicalRecord", "user updated specs of a medical record", recordID, changeLog)
>>>>>>> 01096166741546756a9456fc584388602358902c
	if err != nil {
		return nil, err
	}

	response := &model.UpdateMedicalRecordResponse{
<<<<<<< HEAD
		RecordID: recordID,
=======
		RecordID: results[0].ID,
>>>>>>> 01096166741546756a9456fc584388602358902c
		Message:  "Medical record updated successfully",
	}

	return response, nil
}

// DeleteMedicalRecord is the resolver for the deleteMedicalRecord field.
func (r *mutationResolver) DeleteMedicalRecord(ctx context.Context, recordID string) (*model.DeleteMedicalRecordResponse, error) {
	//panic(fmt.Errorf("not implemented: DeleteMedicalRecord - deleteMedicalRecord"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 执行删除
	_, err := database.DB.Query(`DELETE FROM medical_record WHERE id=$id;`, map[string]interface{}{
		"id": recordID,
	})
	if err != nil {
		return nil, err
	}

	response := &model.DeleteMedicalRecordResponse{
		Message: "Medical record deleted successfully",
	}

	return response, nil
}

// GetHealthMetrics is the resolver for the getHealthMetrics field.
func (r *queryResolver) GetHealthMetrics(ctx context.Context, startDate *string, endDate *string, metricType *string) ([]*model.HealthMetricDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

<<<<<<< HEAD
	var result interface{}
	var err error

	// get all the health metric entries that is associated with the user
	if metricType == nil {
		result, err = database.DB.Query(
			`SELECT * FROM health_metric WHERE user_id = $user_id;`,
			map[string]interface{}{
				"user_id": user.ID,
			},
		)
	} else {
		result, err = database.DB.Query(
			`SELECT * FROM health_metric WHERE user_id = $user_id AND metric_type=$metric_type;`,
			map[string]interface{}{
				"user_id":     user.ID,
				"metric_type": *metricType,
			},
		)
	}

	if err != nil {
		return nil, err
	}

	// unmarshal results into Go objects
	metrics, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}

	// loop through the metrics, convert them into HealthMetricDetail, then return the converted list and nil
	var metricDetails []*model.HealthMetricDetail
	for _, metric := range metrics {
		// check that the metric is within the record time constraints
		if !((startDate != nil && metric.RecordedAt < *startDate) || (endDate != nil && metric.RecordedAt > *endDate)) {
			metricDetail := &model.HealthMetricDetail{
				MetricID:   metric.ID,
				MetricType: metric.MetricType,
				Value:      metric.Value,
				RecordedAt: metric.RecordedAt,
				Unit:       metric.Unit,
			}
			metricDetails = append(metricDetails, metricDetail)
		}
	}

	return metricDetails, nil
=======
	return utils.GetHealthMetrics(*user, startDate, endDate, metricType)
>>>>>>> 01096166741546756a9456fc584388602358902c
}

// GetMedicalRecords is the resolver for the getMedicalRecords field.
func (r *queryResolver) GetMedicalRecords(ctx context.Context) ([]*model.MedicalRecordDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

<<<<<<< HEAD
	// Fetch treatment schedules for the user
	result, err := database.DB.Query(`SELECT * FROM medical_record WHERE user_id=$userID;`, map[string]interface{}{
		"userID": user.ID,
	})
	if err != nil {
		return nil, err
	}

	// TODO: please modify this line as it may result in a bug
	records, err := surrealdb.SmartUnmarshal[[]*model.MedicalRecord](result, nil)
	if err != nil {
		return nil, err
	}

	var record_details []*model.MedicalRecordDetail
	for _, record := range records {
		recordDetail := &model.MedicalRecordDetail{
			RecordID:   record.ID,
			RecordType: record.RecordType,
			Content:    record.Content,
			CreatedAt:  record.CreatedAt,
		}
		record_details = append(record_details, recordDetail)
	}

	return record_details, nil
=======
	return utils.GetMedicalRecords(*user)
>>>>>>> 01096166741546756a9456fc584388602358902c
}
