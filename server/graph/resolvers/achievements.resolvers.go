package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/database"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"

	surrealdb "github.com/surrealdb/surrealdb.go"
)

// CreateAchievementBadge is the resolver for the createAchievementBadge field.
func (r *mutationResolver) CreateAchievementBadge(ctx context.Context, name string, description string, iconURL string) (*model.CreateAchievementBadgeResponse, error) {
	//panic(fmt.Errorf("not implemented: CreateAchievementBadge - createAchievementBadge"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 插入新的成就徽章
	result, err := database.DB.Query(
		`CREATE ONLY achievement_badge:ulid() 
        SET name=$name,
            description=$description,
            iconUrl=$iconUrl,
            createdAt=time::now();`,
		map[string]interface{}{
			"name":        name,
			"description": description,
			"iconUrl":     iconURL,
		},
	)
	if err != nil {
		return nil, err
	}

	newBadge, err := surrealdb.SmartUnmarshal[model.AchievementBadge](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.CreateAchievementBadgeResponse{
		BadgeID: newBadge.ID,
		Message: "Achievement badge created successfully",
	}

	return response, nil
}

// AwardAchievement is the resolver for the awardAchievement field.
func (r *mutationResolver) AwardAchievement(ctx context.Context, badgeID string) (*model.AwardAchievementResponse, error) {
	//panic(fmt.Errorf("not implemented: AwardAchievement - awardAchievement"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 颁发成就徽章
	result, err := database.DB.Query(
		`CREATE ONLY user_achievement:ulid() 
        SET 
			user_id=$user_id,
			badgeID=$badgeID,
            earnedAt=time::now(),
            createdAt=time::now();`,
		map[string]interface{}{
			"user_id": user.ID,
			"badgeID": badgeID,
		},
	)
	if err != nil {
		return nil, err
	}

	newUserAchievement, err := surrealdb.SmartUnmarshal[model.UserAchievement](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.AwardAchievementResponse{
		UserAchievementID: newUserAchievement.ID,
		Message:           "Achievement awarded successfully",
	}

	return response, nil
}

// GetAchievementBadges is the resolver for the getAchievementBadges field.
func (r *queryResolver) GetAchievementBadges(ctx context.Context) ([]*model.AchievementBadgeDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// TODO: could mofify this
	result, err := database.DB.Query(`SELECT * FROM achievement_badge`, map[string]interface{}{})
	if err != nil {
		return nil, err
	}

	badges, err := surrealdb.SmartUnmarshal[[]*model.AchievementBadge](result, nil)
	if err != nil {
		return nil, err
	}

	var badgeDetails []*model.AchievementBadgeDetail
	for _, badge := range badges {
		badgeDetail := &model.AchievementBadgeDetail{
			BadgeID:     badge.ID,
			Name:        badge.Name,
			Description: badge.Description,
			IconURL:     badge.IconURL,
		}
		badgeDetails = append(badgeDetails, badgeDetail)
	}

	return badgeDetails, nil
}

// GetUserAchievements is the resolver for the getUserAchievements field.
func (r *queryResolver) GetUserAchievements(ctx context.Context) ([]*model.UserAchievementDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// Fetch treatment schedules for the user
	result, err := database.DB.Query(`SELECT * FROM user_achievement WHERE user_id=$userID;`, map[string]interface{}{
		"userID": user.ID,
	})
	if err != nil {
		return nil, err
	}

	achievements, err := surrealdb.SmartUnmarshal[[]*model.UserAchievement](result, nil)
	if err != nil {
		return nil, err
	}

	var achievementDetails []*model.UserAchievementDetail
	for _, achievement := range achievements {
		badgeDetail := &model.UserAchievementDetail{
			BadgeID:           achievement.ID,
			UserAchievementID: achievement.ID,
			EarnedAt:          achievement.EarnedAt,
		}
		achievementDetails = append(achievementDetails, badgeDetail)
	}

	return achievementDetails, nil
}
