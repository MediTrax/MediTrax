package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/database"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"
	"time"

	surrealdb "github.com/surrealdb/surrealdb.go"
)

// CreateAchievementBadge is the resolver for the createAchievementBadge field.
func (r *mutationResolver) CreateAchievementBadge(ctx context.Context, name string, description string, iconURL string) (*model.CreateAchievementBadgeResponse, error) {
	//panic(fmt.Errorf("not implemented: CreateAchievementBadge - createAchievementBadge"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 插入新的成就徽章
	result, err := database.DB.Query(
		`CREATE ONLY achievement_badge:ulid() 
        SET name=$name,
            description=$description,
            iconUrl=$iconUrl,
            createdAt=<datetime>$now;`,
		map[string]interface{}{
			"name":        name,
			"description": description,
			"iconUrl":     iconURL,
			"now":         time.Now().UTC(),
		},
	)
	if err != nil {
		return nil, err
	}

	newBadge, err := surrealdb.SmartUnmarshal[model.AchievementBadge](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.CreateAchievementBadgeResponse{
		BadgeID: newBadge.ID,
		Message: "Achievement badge created successfully",
	}

	return response, nil
}

// AwardAchievement is the resolver for the awardAchievement field.
func (r *mutationResolver) AwardAchievement(ctx context.Context, badgeID string) (*model.AwardAchievementResponse, error) {
	// 检查用户是否已登录
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// 验证 badgeID 是否有效
	checkBadgeQuery := `
		SELECT * FROM achievement_badge
		WHERE id = $badgeID;
	`
	checkResult, err := database.DB.Query(checkBadgeQuery, map[string]interface{}{
		"badgeID": badgeID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to validate badge ID: %w", err)
	}

	// 如果查询结果为空，说明 badgeID 无效
	badges, err := surrealdb.SmartUnmarshal[[]model.AchievementBadge](checkResult, nil)
	if err != nil || len(badges) == 0 {
		return nil, fmt.Errorf("invalid badge ID")
	}

	// 如果 badgeID 有效，则颁发成就徽章
	createAchievementQuery := `
		CREATE ONLY user_achievement:ulid()
		SET 
			userId = $userId,
			badgeID = $badgeID,
			earnedAt = <datetime>$now,
			createdAt = <datetime>$now;
	`
	createResult, err := database.DB.Query(createAchievementQuery, map[string]interface{}{
		"userId":  user.ID,
		"badgeID": badgeID,
		"now":     time.Now().UTC(),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create user achievement: %w", err)
	}

	// 解析创建结果
	newUserAchievement, err := surrealdb.SmartUnmarshal[model.UserAchievement](createResult, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to parse new user achievement: %w", err)
	}

	// 构造响应
	response := &model.AwardAchievementResponse{
		UserAchievementID: newUserAchievement.ID,
		Message:           "Achievement awarded successfully",
	}

	return response, nil
}

// EarnPoints is the resolver for the earnPoints field.
func (r *mutationResolver) EarnPoints(ctx context.Context, pointsEarned float64, reason string) (*model.EarnPointsResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	if pointsEarned <= 0 {
		return nil, fmt.Errorf("earned points must be positive number")
	}

	result, err := database.DB.Query(
		`CREATE ONLY point_record:ulid() 
        SET userId=$userId,
		pointsEarned=$pointsEarned,
		reason=$reason,
		earnedAt=<datetime>$now;`,
		map[string]interface{}{
			"userId":       user.ID,
			"pointsEarned": pointsEarned,
			"reason":       reason,
			"now":          time.Now().UTC(),
		},
	)
	if err != nil {
		return nil, err
	}

	newRecord, err := surrealdb.SmartUnmarshal[model.UserPointRecord](result, nil)
	if err != nil {
		return nil, err
	}

	result, err = database.DB.Query(`UPDATE ONLY $id 
		SET points+=$pointsEarned;`,
		map[string]interface{}{
			"id":           user.ID,
			"pointsEarned": pointsEarned,
		})

	if err != nil {
		return nil, err
	}
	updatedUser, err := surrealdb.SmartUnmarshal[model.User](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.EarnPointsResponse{
		UpdatedPoints: updatedUser.Points,
		Message:       fmt.Sprintf("%f points successfully added to user", newRecord.PointsEarned),
	}

	return response, nil
}

// GetAchievementBadges is the resolver for the getAchievementBadges field.
func (r *queryResolver) GetAchievementBadges(ctx context.Context) ([]*model.AchievementBadgeDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// TODO: could mofify this
	result, err := database.DB.Query(`SELECT * FROM achievement_badge ORDER BY createdAt DESC`, nil)
	if err != nil {
		return nil, err
	}

	badges, err := surrealdb.SmartUnmarshal[[]*model.AchievementBadge](result, nil)
	if err != nil {
		return nil, err
	}

	var badgeDetails []*model.AchievementBadgeDetail
	for _, badge := range badges {
		badgeDetail := &model.AchievementBadgeDetail{
			BadgeID:     badge.ID,
			Name:        badge.Name,
			Description: badge.Description,
			IconURL:     badge.IconURL,
			CreatedAt:   badge.CreatedAt,
		}
		badgeDetails = append(badgeDetails, badgeDetail)
	}

	return badgeDetails, nil
}

// GetUserAchievements is the resolver for the getUserAchievements field.
func (r *queryResolver) GetUserAchievements(ctx context.Context) ([]*model.UserAchievementDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// Fetch treatment schedules for the user
	result, err := database.DB.Query(`SELECT * FROM user_achievement WHERE userId=$userID ORDER BY earnedAt DESC;`, map[string]interface{}{
		"userID": user.ID,
	})
	if err != nil {
		return nil, err
	}

	achievements, err := surrealdb.SmartUnmarshal[[]*model.UserAchievement](result, nil)
	if err != nil {
		return nil, err
	}

	var achievementDetails []*model.UserAchievementDetail
	for _, achievement := range achievements {
		badgeDetail := &model.UserAchievementDetail{
			BadgeID:           achievement.BadgeID,
			UserAchievementID: achievement.ID,
			EarnedAt:          achievement.EarnedAt,
		}
		achievementDetails = append(achievementDetails, badgeDetail)
	}

	return achievementDetails, nil
}

// GetUserPointRecords is the resolver for the getUserPointRecords field.
func (r *queryResolver) GetUserPointRecords(ctx context.Context) ([]*model.UserPointRecordDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// get all the medication reminders for the user
	result, err := database.DB.Query(
		`SELECT * FROM point_record WHERE userId = $userId;`,
		map[string]interface{}{
			"userId": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	records, err := surrealdb.SmartUnmarshal[[]model.UserPointRecord](result, nil)
	if err != nil {
		return nil, err
	}

	// loop through the reminders, convert them into MedicationReminderDetails, then return the converted list and nil
	var recordDetails []*model.UserPointRecordDetail
	for _, record := range records {
		reminderDetail := &model.UserPointRecordDetail{
			RecordID:     record.ID,
			PointsEarned: record.PointsEarned,
			Reason:       record.Reason,
			EarnedAt:     record.EarnedAt,
		}
		recordDetails = append(recordDetails, reminderDetail)
	}

	return recordDetails, nil
}
