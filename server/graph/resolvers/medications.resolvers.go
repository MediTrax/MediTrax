package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/custom"
	"meditrax/graph/database"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"
	"meditrax/graph/utils"
	"strings"
	"time"

	surrealdb "github.com/surrealdb/surrealdb.go"
)

// AddMedication is the resolver for the addMedication field.
func (r *mutationResolver) AddMedication(ctx context.Context, name string, dosage float64, unit string, frequency string, inventory float64) (*model.AddMedicationResponse, error) {
	// check if they are logged in correctly
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// query database for medications for the same user with the same name
	result, err := database.DB.Query(
		`SELECT * FROM medication WHERE name=$name AND user_id=$user_id;`,
		map[string]interface{}{
			"name":    name,
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	medications, err := surrealdb.SmartUnmarshal[[]*model.Medication](result, nil)
	if err != nil {
		return nil, err
	}

	if len(medications) > 0 {
		return nil, fmt.Errorf("identical medication name already exists for the user, please use update medication instead")
	}

	// check the validity of the given frequency
	if _, _, err := utils.FrequencyParser(frequency); err != nil {
		return nil, fmt.Errorf("invalid frequency format %s for medication %s", frequency, name)
	}

	// create new Medication record
	result, err = database.DB.Query(
		`CREATE ONLY medication:ulid()
		SET name=$name,
		dosage=$dosage,
		unit=$unit,
		frequency=$frequency,
		inventory=$inventory,
		user_id=$user_id,
		created_at=time::now(),
		updated_at=time::now();
		`,
		map[string]interface{}{
			"name":      name,
			"dosage":    dosage,
			"unit":      unit,
			"frequency": frequency,
			"inventory": inventory,
			"user_id":   user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshall the returned results
	newMedication, err := surrealdb.SmartUnmarshal[model.Medication](result, nil)
	if err != nil {
		return nil, err
	}
	// create response
	response := &model.AddMedicationResponse{
		MedicationID: newMedication.ID,
		Message:      fmt.Sprintf("Medication %s added successfully", newMedication.Name),
	}

	return response, nil
}

// UpdateMedication is the resolver for the updateMedication field.
func (r *mutationResolver) UpdateMedication(ctx context.Context, medicationID string, name *string, dosage *float64, unit *string, frequency *string, inventory *float64) (*model.UpdateMedicationResponse, error) {
	// check if they are logged in correctly
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check if id is legal
	if !utils.MatchID(medicationID, "medication") {
		return nil, fmt.Errorf("illegal medication id")
	}

	result, err := database.DB.Query(
		`SELECT * FROM ONLY $medicationId WHERE user_id=$user_id;`,
		map[string]interface{}{
			"medicationId": medicationID,
			"user_id":      user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	original, err := surrealdb.SmartUnmarshal[model.Medication](result, nil)
	if err != nil {
		return nil, err
	}

	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": medicationID, "user_id": user.ID}
	var changeLog []utils.ChangeLog

	// Prepare the fields to be updated
	updateFields := []string{}
	if name != nil {
		updateValues["name"] = *name
		updateFields = append(updateFields, "name = $name")
		change := utils.ChangeLog{
			Field: "name",
			From:  original.Name,
			To:    *name,
		}
		changeLog = append(changeLog, change)
	}
	if dosage != nil {
		updateValues["dosage"] = *dosage
		updateFields = append(updateFields, "dosage = $dosage")
		change := utils.ChangeLog{
			Field: "dosage",
			From:  fmt.Sprintf("%f", original.Dosage),
			To:    fmt.Sprintf("%f", *dosage),
		}
		changeLog = append(changeLog, change)
	}
	if unit != nil {
		updateValues["unit"] = *unit
		updateFields = append(updateFields, "unit = $unit")
		change := utils.ChangeLog{
			Field: "unit",
			From:  original.Unit,
			To:    *unit,
		}
		changeLog = append(changeLog, change)
	}
	if frequency != nil {
		// Validate the frequency format
		if _, _, err := utils.FrequencyParser(*frequency); err != nil {
			return nil, err // Return the error if format is invalid
		}
		updateValues["frequency"] = *frequency
		updateFields = append(updateFields, "frequency = $frequency")
		change := utils.ChangeLog{
			Field: "frequency",
			From:  original.Frequency,
			To:    *frequency,
		}
		changeLog = append(changeLog, change)
	}
	if inventory != nil {
		updateValues["inventory"] = *inventory
		updateFields = append(updateFields, "inventory = $inventory")
		change := utils.ChangeLog{
			Field: "inventory",
			From:  fmt.Sprintf("%f", original.Inventory),
			To:    fmt.Sprintf("%f", *inventory),
		}
		changeLog = append(changeLog, change)
	}

	// Construct the final query with the medicationID in quotes
	query := fmt.Sprintf("UPDATE $id SET %s WHERE user_id=$user_id;", strings.Join(updateFields, ", "))

	// send the UPDATE query
	result, err = database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// unmarshal the results and check for errors
	results, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id. no associated medication object found")
	}

	// add to activity log
	err = utils.AddActivityLogs(user.ID, "updateMedication", "user updated specs of a medicaion", medicationID, changeLog)
	if err != nil {
		return nil, err
	}

	// create response
	response := &model.UpdateMedicationResponse{
		MedicationID: results[0].ID,
		Message:      "Medication updated successfully",
	}

	// Return the response with the medication ID and a success message
	return response, nil
}

// DeleteMedication is the resolver for the deleteMedication field.
func (r *mutationResolver) DeleteMedication(ctx context.Context, medicationID string) (*model.DeleteMedicationResponse, error) {
	//TODO: delete associated medication reminders
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check legality of the provided id
	if !utils.MatchID(medicationID, "medication") {
		return nil, fmt.Errorf("illegal medication id")
	}

	// Execute the query
	result, err := database.DB.Query(
		`DELETE $id WHERE user_id=$user_id RETURN BEFORE;`,
		map[string]interface{}{
			"id":      medicationID,
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err // Return the error if the query fails
	}

	// unmarshal results and check for errors
	results, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no associated medication object found")
	}

	_, err = database.DB.Query(
		`DELETE medication_reminder WHERE medication_id=$medication_id;`,
		map[string]interface{}{
			"medication_id": medicationID,
		},
	)
	if err != nil {
		return nil, err
	}

	// create response
	response := &model.DeleteMedicationResponse{
		Message: fmt.Sprintf("Medication %s with name %s deleted successfully", results[0].ID, results[0].Name),
	}

	// Return the response with the medication ID and a success message
	return response, nil
}

// CreateMedicationReminder is the resolver for the createMedicationReminder field.
func (r *mutationResolver) CreateMedicationReminder(ctx context.Context, medicationID string, reminderTime string) (*model.CreateMedicationReminderResponse, error) {
	// check legality of both user and medication id
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	if !utils.MatchID(medicationID, "medication") {
		return nil, fmt.Errorf("illegal medication id")
	}

	// query for the medication and check if it exists
	result, err := database.DB.Query(
		`SELECT * FROM $medication_id WHERE user_id = $user_id;`,
		map[string]interface{}{
			"medication_id": medicationID,
			"user_id":       user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	medications, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
	if err != nil {
		return nil, err
	}
	if len(medications) < 1 {
		return nil, fmt.Errorf("invalid medication id or medication id not associated with user")
	}

	// query database for medications with the same reminder time
	result, err = database.DB.Query(
		`SELECT * FROM medication_reminder 
		WHERE medication_id=$medication_id AND user_id=$user_id AND reminder_time=$reminder_time;`,
		map[string]interface{}{
			"medication_id": medicationID,
			"user_id":       user.ID,
			"reminder_time": reminderTime,
		},
	)
	if err != nil {
		return nil, err
	}
	reminders, err := surrealdb.SmartUnmarshal[[]model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}
	if len(reminders) > 0 {
		return nil, fmt.Errorf("identical medication reminder for the user already exists")
	}

	// finally, send the create reminder query
	result, err = database.DB.Query(
		`CREATE ONLY medication_reminder:ulid()
		SET medication_id=$medication_id,
		user_id=$user_id,
		reminder_time=$reminder_time,
		is_taken=false,
		created_at=time::now()
		`,
		map[string]interface{}{
			"medication_id": medicationID,
			"user_id":       user.ID,
			"reminder_time": reminderTime,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshal the results of the CREATE query
	newReminder, err := surrealdb.SmartUnmarshal[model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}

	// create response
	response := &model.CreateMedicationReminderResponse{
		ReminderID: newReminder.ID,
		Message:    "new reminder created successfully",
	}
	return response, nil
}

// UpdateMedicationReminder is the resolver for the updateMedicationReminder field.
func (r *mutationResolver) UpdateMedicationReminder(ctx context.Context, reminderID string, reminderTime *string, isTaken *bool) (*model.UpdateMedicationReminderResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check legality of the reminder id
	if !utils.MatchID(reminderID, "medication_reminder") {
		return nil, fmt.Errorf("illegal reminder id")
	}

	// query database to see if the reminder exists
	result, err := database.DB.Query(
		`SELECT * FROM medication_reminder WHERE id=$reminder_id AND user_id=$user_id;`,
		map[string]interface{}{
			"reminder_id": reminderID,
			"user_id":     user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	reminders, err := surrealdb.SmartUnmarshal[[]model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}
	if len(reminders) < 1 {
		return nil, fmt.Errorf("wrong medication reminder id, no reminder found")
	}

	// get the reminder before updating
	remBefore := reminders[0]

	// logic for when the reminder changes from not taken to taken, subtract the medication's remaining by its dosage
	if isTaken != nil {
		if !remBefore.IsTaken && *isTaken {
			// deprecated
			result, err = database.DB.Query(
				`SELECT * FROM medication WHERE id=$med_id;`,
				map[string]interface{}{
					"med_id": remBefore.MedicationID,
				},
			)

			if err != nil {
				return nil, err
			}

			// verify that there is a medication linked to this reminder
			// NOTE: should NEVER happen since deleting a medication also deletes the reminder
			medications, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
			if err != nil {
				return nil, err
			}
			if len(medications) == 0 {
				return nil, fmt.Errorf("no medication linked to reminder found")
			}

			// calculate the new inventory
			new_inventory := medications[0].Inventory - medications[0].Dosage
			// if the inventory becomes negative, throw an error
			if new_inventory < 0 {
				return nil, fmt.Errorf("negative inventory")
			}

			// update the inventory
			_, err = database.DB.Query(
				`UPDATE ONLY $id SET inventory=$inventory`,
				map[string]interface{}{
					"id":        remBefore.MedicationID,
					"inventory": new_inventory,
				},
			)
			if err != nil {
				return nil, err
			}

			err = utils.AddActivityLogs(user.ID, "updateMedicationReminder", "decrease medication inventory after medicaion is taken",
				remBefore.MedicationID, []utils.ChangeLog{
					{
						Field: "inventory",
						From:  fmt.Sprintf("%f", medications[0].Inventory),
						To:    fmt.Sprintf("%f", new_inventory),
					},
				})
			if err != nil {
				return nil, err
			}
		}
	}

	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": reminderID}

	var changeLog []utils.ChangeLog

	// Prepare the fields to be updated
	updateFields := []string{}
	if reminderTime != nil {
		updateValues["reminder_time"] = *reminderTime
		updateFields = append(updateFields, "reminder_time = $reminder_time")
		change := utils.ChangeLog{
			Field: "reminder_time",
			From:  remBefore.ReminderTime,
			To:    *reminderTime,
		}
		changeLog = append(changeLog, change)
	}
	if isTaken != nil {
		updateValues["is_taken"] = *isTaken
		updateFields = append(updateFields, "is_taken = $is_taken")
		change := utils.ChangeLog{
			Field: "is_taken",
			From:  fmt.Sprintf("%t", remBefore.IsTaken),
			To:    fmt.Sprintf("%t", *isTaken),
		}
		changeLog = append(changeLog, change)
	}

	// Construct the final query
	query := fmt.Sprintf("UPDATE $id SET %s;", strings.Join(updateFields, ", "))
	// send the UPDATE query
	result, err = database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	err = utils.AddActivityLogs(user.ID, "updateMedicationReminder", "user updated specs of a medicaion reminder", reminderID, changeLog)
	if err != nil {
		return nil, err
	}

	// unmarshal results and construct response
	results, err := surrealdb.SmartUnmarshal[[]*model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}
	response := &model.UpdateMedicationReminderResponse{
		ReminderID: results[0].ID,
		Message:    "Medication reminder updated successfully",
	}

	return response, nil
}

// TakeMedication is the resolver for the takeMedication field.
func (r *mutationResolver) TakeMedication(ctx context.Context, reminderID *string) (*model.TakeMedicationResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	if reminderID == nil {
		return nil, fmt.Errorf("no medication id given")
	}

	// check legality of the reminder id
	if !utils.MatchID(*reminderID, "medication_reminder") {
		return nil, fmt.Errorf("illegal reminder id")
	}

	// query database to see if the reminder exists
	result, err := database.DB.Query(
		`SELECT * FROM $reminder_id WHERE user_id=$user_id;`,
		map[string]interface{}{
			"reminder_id": reminderID,
			"user_id":     user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	reminders, err := surrealdb.SmartUnmarshal[[]model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}
	if len(reminders) < 1 {
		return nil, fmt.Errorf("wrong medication reminder id, no reminder associated with userfound")
	}

	reminder := reminders[0]
	if reminder.IsTaken {
		return nil, fmt.Errorf("reminder already taken, cannot take again")
	}

	/* Decrease inventory of linked medication */
	result, err = database.DB.Query(
		`SELECT * FROM medication WHERE id=$med_id;`,
		map[string]interface{}{
			"med_id": reminder.MedicationID,
		},
	)
	if err != nil {
		return nil, err
	}

	// verify that there is a medication linked to this reminder
	// NOTE: should NEVER happen since deleting a medication also deletes the reminder
	medications, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
	if err != nil {
		return nil, err
	}
	if len(medications) == 0 {
		return nil, fmt.Errorf("no medication linked to reminder found")
	}

	// calculate the new inventory
	new_inventory := medications[0].Inventory - medications[0].Dosage
	// if the inventory becomes negative, throw an error
	if new_inventory < 0 {
		return nil, fmt.Errorf("negative inventory")
	}

	// update the inventory
	_, err = database.DB.Query(
		`UPDATE ONLY $id SET inventory=$inventory`,
		map[string]interface{}{
			"id":        reminder.MedicationID,
			"inventory": new_inventory,
		},
	)
	if err != nil {
		return nil, err
	}

	err = utils.AddActivityLogs(user.ID, "takeMedication", "decrease medication inventory after user takes medication",
		reminder.MedicationID, []utils.ChangeLog{
			{
				Field: "inventory",
				From:  fmt.Sprintf("%f", medications[0].Inventory),
				To:    fmt.Sprintf("%f", new_inventory),
			},
		})
	if err != nil {
		return nil, err
	}

	/* Update the reminder itself */
	// calculate next reminder time
	current_time, err := custom.UnmarshalDateTime(reminder.ReminderTime)
	if err != nil {
		return nil, fmt.Errorf("error unmarshaling reminder time: %e", err)
	}
	_, days, err := utils.FrequencyParser(medications[0].Frequency)
	if err != nil {
		return nil, fmt.Errorf("error parsing frequency of medication: %e", err)
	}
	next_reminder_time := time.Time.Add(current_time, time.Hour*time.Duration(24*days))

	// update reminder
	_, err = database.DB.Query(`
		UPDATE $id SET reminder_time=$reminder_time;`,
		map[string]interface{}{
			"id":            *reminderID,
			"reminder_time": next_reminder_time,
		})
	if err != nil {
		return nil, err
	}

	// add to change log
	err = utils.AddActivityLogs(user.ID, "takeMedication", "user take medication, update reminder time", *reminderID,
		[]utils.ChangeLog{
			{
				Field: "reminder_time",
				From:  reminder.ReminderTime,
				To:    next_reminder_time.Format("2006-01-02T15:04:05.000"),
			},
		})
	if err != nil {
		return nil, err
	}

	response := &model.TakeMedicationResponse{
		Message: "medication taken successfully",
	}

	return response, nil
}

// DeleteMedicationReminder is the resolver for the deleteMedicationReminder field.
func (r *mutationResolver) DeleteMedicationReminder(ctx context.Context, reminderID string) (*model.DeleteMedicationReminderResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check legality of the provided id
	if !utils.MatchID(reminderID, "medication_reminder") {
		return nil, fmt.Errorf("illegal medication reminder id")
	}

	// Execute the query
	result, err := database.DB.Query(
		`DELETE $id WHERE user_id=$user_id RETURN BEFORE;`,
		map[string]interface{}{
			"id":      reminderID,
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err // Return the error if the query fails
	}

	// unmarshal results and check for errors
	results, err := surrealdb.SmartUnmarshal[[]model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no associated medication reminder object found")
	}

	// create response
	response := &model.DeleteMedicationReminderResponse{
		Message: fmt.Sprintf("Medication reminder %s for medication %s was deleted successfully", results[0].ID, results[0].MedicationID),
	}

	// Return the response with the medication ID and a success message
	return response, nil
}

// CreateTreatmentSchedule is the resolver for the createTreatmentSchedule field.
func (r *mutationResolver) CreateTreatmentSchedule(ctx context.Context, treatmentType string, scheduledTime string, location string, notes *string) (*model.CreateTreatmentScheduleResponse, error) {
	// 验证用户权限
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// TODO: check for and reject duplicates

	// 创建治疗计划记录
	result, err := database.DB.Query(
		`CREATE ONLY treatment_schedule:ulid()
        SET treatmentType=$treatmentType,
        scheduledTime=$scheduledTime,
        location=$location,
        notes=$notes,
        user_id=$user_id,
        created_at=time::now(),
        updated_at=time::now();`,
		map[string]interface{}{
			"treatmentType": treatmentType,
			"scheduledTime": scheduledTime,
			"location":      location,
			"notes":         notes,
			"user_id":       user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// 解析返回结果
	newSchedule, err := surrealdb.SmartUnmarshal[model.TreatmentSchedule](result, nil)
	if err != nil {
		return nil, err
	}
	response := &model.CreateTreatmentScheduleResponse{
		ScheduleID: newSchedule.ID,
		Message:    "Treatment schedule created successfully",
	}

	return response, nil
}

// UpdateTreatmentSchedule is the resolver for the updateTreatmentSchedule field.
func (r *mutationResolver) UpdateTreatmentSchedule(ctx context.Context, scheduleID string, treatmentType *string, scheduledTime *string, location *string, notes *string) (*model.UpdateTreatmentScheduleResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	if !utils.MatchID(scheduleID, "treatment_schedule") {
		return nil, fmt.Errorf("illegal schedule id")
	}

	// get the original entry before updating
	result, err := database.DB.Query(
		`SELECT * FROM ONLY $scheduleId WHERE user_id=$user_id;`,
		map[string]interface{}{
			"scheduleId": scheduleID,
			"user_id":    user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	original, err := surrealdb.SmartUnmarshal[model.TreatmentSchedule](result, nil)
	if err != nil {
		return nil, err
	}

	// 准备更新字段
	updateValues := map[string]interface{}{
		"id":      scheduleID,
		"user_id": user.ID,
	}
	updateFields := []string{}
	var changeLog []utils.ChangeLog

	if treatmentType != nil {
		updateValues["treatmentType"] = *treatmentType
		updateFields = append(updateFields, "treatmentType = $treatmentType")
		change := utils.ChangeLog{
			Field: "treatmentType",
			From:  original.TreatmentType,
			To:    *treatmentType,
		}
		changeLog = append(changeLog, change)
	}
	if scheduledTime != nil {
		updateValues["scheduledTime"] = *scheduledTime
		updateFields = append(updateFields, "scheduledTime = $scheduledTime")
		change := utils.ChangeLog{
			Field: "scheduledTime",
			From:  original.ScheduledTime,
			To:    *scheduledTime,
		}
		changeLog = append(changeLog, change)
	}
	if location != nil {
		updateValues["location"] = *location
		updateFields = append(updateFields, "location = $location")
		change := utils.ChangeLog{
			Field: "location",
			From:  original.Location,
			To:    *location,
		}
		changeLog = append(changeLog, change)
	}
	if notes != nil {
		updateValues["notes"] = *notes
		updateFields = append(updateFields, "notes = $notes")
		change := utils.ChangeLog{
			Field: "notes",
			From:  *original.Notes,
			To:    *notes,
		}
		if original.Notes == nil {
			change.From = "Null"
		}
		changeLog = append(changeLog, change)
	}
	updateFields = append(updateFields, "updated_at = time::now()")

	// 构建并执行更新查询
	query := fmt.Sprintf("UPDATE $id SET %s WHERE user_id = $user_id;", strings.Join(updateFields, ", "))
	result, err = database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// 验证更新结果
	schedules, err := surrealdb.SmartUnmarshal[[]model.TreatmentSchedule](result, nil)
	if err != nil {
		return nil, err
	}
	if len(schedules) == 0 {
		return nil, fmt.Errorf("invalid id. no associated treatment schedule found")
	}

	// add to activity log
	err = utils.AddActivityLogs(user.ID, "updateTreatmentSchedule", "user updated specs of a treatment schedule", scheduleID, changeLog)
	if err != nil {
		return nil, err
	}

	response := &model.UpdateTreatmentScheduleResponse{
		ScheduleID: schedules[0].ID,
		Message:    "Treatment schedule updated successfully",
	}

	return response, nil
}

// DeleteTreatmentSchedule is the resolver for the deleteTreatmentSchedule field.
func (r *mutationResolver) DeleteTreatmentSchedule(ctx context.Context, scheduleID string) (*model.DeleteTreatmentScheduleResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	if !utils.MatchID(scheduleID, "treatment_schedule") {
		return nil, fmt.Errorf("illegal schedule id")
	}

	// 执行删除操作
	result, err := database.DB.Query(
		`DELETE $id WHERE user_id = $user_id RETURN BEFORE;`,
		map[string]interface{}{
			"id":      scheduleID,
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// 验证删除结果
	schedules, err := surrealdb.SmartUnmarshal[[]model.TreatmentSchedule](result, nil)
	if err != nil {
		return nil, err
	}
	if len(schedules) == 0 {
		return nil, fmt.Errorf("schedule not found")
	}

	response := &model.DeleteTreatmentScheduleResponse{
		Message: fmt.Sprintf("Treatment schedule %s deleted successfully", schedules[0].ID),
	}

	return response, nil
}

// GetMedications is the resolver for the getMedications field.
func (r *queryResolver) GetMedications(ctx context.Context) ([]*model.MedicationDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	return utils.GetMedications(*user)
}

// GetMedicationReminders is the resolver for the getMedicationReminders field.
func (r *queryResolver) GetMedicationReminders(ctx context.Context) ([]*model.MedicationReminderDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// get all the medication reminders for the user
	result, err := database.DB.Query(
		`SELECT * FROM medication_reminder WHERE user_id = $user_id;`,
		map[string]interface{}{
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	reminders, err := surrealdb.SmartUnmarshal[[]model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}

	// loop through the reminders, convert them into MedicationReminderDetails, then return the converted list and nil
	var reminderDetails []*model.MedicationReminderDetail
	for _, rem := range reminders {
		reminderDetail := &model.MedicationReminderDetail{
			ReminderID:   rem.ID,
			MedicationID: rem.MedicationID,
			ReminderTime: rem.ReminderTime,
			IsTaken:      rem.IsTaken,
		}
		reminderDetails = append(reminderDetails, reminderDetail)
	}

	return reminderDetails, nil
}

// GetTreatmentSchedules is the resolver for the getTreatmentSchedules field.
func (r *queryResolver) GetTreatmentSchedules(ctx context.Context) ([]*model.TreatmentScheduleDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	return utils.GetTreatmentSchedules(*user)
}
