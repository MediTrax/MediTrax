package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/database"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"
	"meditrax/graph/utils"
	"strings"

	surrealdb "github.com/surrealdb/surrealdb.go"
)

// AddMedication is the resolver for the addMedication field.
func (r *mutationResolver) AddMedication(ctx context.Context, name string, dosage float64, unit string, frequency string, inventory float64) (*model.AddMedicationResponse, error) {
	// check if they are logged in correctly
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// query database for medications for the same user with the same name
	result, err := database.DB.Query(
		`SELECT * FROM medication WHERE name=$name AND user_id=$user_id;`,
		map[string]interface{}{
			"name":    name,
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	println("Finished query")
	medications, err := surrealdb.SmartUnmarshal[[]*model.Medication](result, nil)
	if err != nil {
		return nil, err
	}

	println("Finished unmarshaling medications")
	if len(medications) > 0 {
		return nil, fmt.Errorf("identical medication name already exists for the user, please use update medication instead")
	}

	// check the validity of the given frequency
	if _, _, err := utils.FrequencyParser(frequency); err != nil {
		return nil, fmt.Errorf("invalid frequency format %s for medication %s", frequency, name)
	}

	// create new Medication record
	result, err = database.DB.Query(
		`CREATE ONLY medication:ulid()
		SET name=$name,
		dosage=$dosage,
		unit=$unit,
		frequency=$frequency,
		inventory=$inventory,
		user_id=$user_id,
		created_at=time::now(),
		updated_at=time::now();
		`,
		map[string]interface{}{
			"name":      name,
			"dosage":    dosage,
			"unit":      unit,
			"frequency": frequency,
			"inventory": inventory,
			"user_id":   user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshall the returned results
	newMedication, err := surrealdb.SmartUnmarshal[model.Medication](result, nil)
	if err != nil {
		return nil, err
	}
	// create response
	response := &model.AddMedicationResponse{
		MedicationID: newMedication.ID,
		Message:      fmt.Sprintf("Medication %s added successfully", newMedication.Name),
	}

	return response, nil
}

// UpdateMedication is the resolver for the updateMedication field.
func (r *mutationResolver) UpdateMedication(ctx context.Context, medicationID string, name *string, dosage *float64, unit *string, frequency *string, inventory *float64) (*model.UpdateMedicationResponse, error) {
	// check if they are logged in correctly
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check if id is legal
	if !utils.MatchID(medicationID, "medication") {
		return nil, fmt.Errorf("illegal medication id")
	}

	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": medicationID, "user_id": user.ID}

	// Prepare the fields to be updated
	updateFields := []string{}
	if name != nil {
		updateValues["name"] = *name
		updateFields = append(updateFields, "name = $name")
	}
	if dosage != nil {
		updateValues["dosage"] = *dosage
		updateFields = append(updateFields, "dosage = $dosage")
	}
	if unit != nil {
		updateValues["unit"] = *unit
		updateFields = append(updateFields, "unit = $unit")
	}
	if frequency != nil {
		// Validate the frequency format
		if _, _, err := utils.FrequencyParser(*frequency); err != nil {
			return nil, err // Return the error if format is invalid
		}
		updateValues["frequency"] = *frequency
		updateFields = append(updateFields, "frequency = $frequency")
	}
	if inventory != nil {
		updateValues["inventory"] = *inventory
		updateFields = append(updateFields, "inventory = $inventory")
	}

	// Construct the final query with the medicationID in quotes
	query := fmt.Sprintf("UPDATE $id SET %s WHERE user_id=$user_id;", strings.Join(updateFields, ", "))

	// send the UPDATE query
	result, err := database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// unmarshal the results and check for errors
	results, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id. no associated medication object found")
	}

	// create response
	response := &model.UpdateMedicationResponse{
		MedicationID: results[0].ID,
		Message:      "Medication updated successfully",
	}

	// Return the response with the medication ID and a success message
	return response, nil
}

// DeleteMedication is the resolver for the deleteMedication field.
func (r *mutationResolver) DeleteMedication(ctx context.Context, medicationID string) (*model.DeleteMedicationResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check legality of the provided id
	if !utils.MatchID(medicationID, "medication") {
		return nil, fmt.Errorf("illegal medication id")
	}

	// Execute the query
	result, err := database.DB.Query(
		`DELETE $id WHERE user_id=$user_id RETURN BEFORE;`,
		map[string]interface{}{
			"id":      medicationID,
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err // Return the error if the query fails
	}

	// unmarshal results and check for errors
	results, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no associated medication object found")
	}

	// create response
	response := &model.DeleteMedicationResponse{
		Message: fmt.Sprintf("Medication %s with name %s deleted successfully", results[0].ID, results[0].Name),
	}

	// Return the response with the medication ID and a success message
	return response, nil
}

// CreateMedicationReminder is the resolver for the createMedicationReminder field.
func (r *mutationResolver) CreateMedicationReminder(ctx context.Context, medicationID string, reminderTime string) (*model.CreateMedicationReminderResponse, error) {
	// check legality of both user and medication id
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	if !utils.MatchID(medicationID, "medication") {
		return nil, fmt.Errorf("illegal medication id")
	}

	// query for the medication and check if it exists
	result, err := database.DB.Query(
		`SELECT * FROM $medication_id WHERE user_id = $user_id;`,
		map[string]interface{}{
			"medication_id": medicationID,
			"user_id":       user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	medications, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
	if err != nil {
		return nil, err
	}
	if len(medications) < 1 {
		return nil, fmt.Errorf("invalid medication id or medication id not associated with user")
	}

	// query database for medications with the same reminder time
	result, err = database.DB.Query(
		`SELECT * FROM medication_reminder 
		WHERE medication_id=$medication_id AND user_id=$user_id AND reminder_time=$reminder_time;`,
		map[string]interface{}{
			"medication_id": medicationID,
			"user_id":       user.ID,
			"reminder_time": reminderTime,
		},
	)
	if err != nil {
		return nil, err
	}
	reminders, err := surrealdb.SmartUnmarshal[[]model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}
	if len(reminders) > 0 {
		return nil, fmt.Errorf("identical medication reminder for the user already exists")
	}

	// finally, send the create reminder query
	result, err = database.DB.Query(
		`CREATE ONLY medication_reminder:ulid()
		SET medication_id=$medication_id,
		user_id=$user_id,
		reminder_time=$reminder_time,
		is_taken=false,
		created_at=time::now()
		`,
		map[string]interface{}{
			"medication_id": medicationID,
			"user_id":       user.ID,
			"reminder_time": reminderTime,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshal the results of the CREATE query
	newReminder, err := surrealdb.SmartUnmarshal[model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}

	// create response
	response := &model.CreateMedicationReminderResponse{
		ReminderID: newReminder.ID,
		Message:    "new reminder created successfully",
	}
	return response, nil
}

// UpdateMedicationReminder is the resolver for the updateMedicationReminder field.
func (r *mutationResolver) UpdateMedicationReminder(ctx context.Context, reminderID string, reminderTime *string, isTaken *bool) (*model.UpdateMedicationReminderResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check legality of the reminder id
	if !utils.MatchID(reminderID, "medication_reminder") {
		return nil, fmt.Errorf("illegal reminder id")
	}

	// query database to see if the reminder exists
	result, err := database.DB.Query(
		`SELECT * FROM medication_reminder WHERE id=$reminder_id AND user_id=$user_id;`,
		map[string]interface{}{
			"reminder_id": reminderID,
			"user_id":     user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	reminders, err := surrealdb.SmartUnmarshal[[]model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}
	if len(reminders) < 1 {
		return nil, fmt.Errorf("wrong medication reminder id, no reminder found")
	}

	// get the reminder before updating
	remBefore := reminders[0]

	// logic for when the reminder changes from not taken to taken, subtract the medication's remaining by its dosage
	if isTaken != nil {
		if !remBefore.IsTaken && *isTaken {
			result, err = database.DB.Query(
				`SELECT * FROM medication WHERE id=$med_id;`,
				map[string]interface{}{
					"med_id": remBefore.MedicationID,
				},
			)

			if err != nil {
				return nil, err
			}

			// verify that there is a medication linked to this reminder
			medications, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
			if err != nil {
				return nil, err
			}
			if len(medications) == 0 {
				return nil, fmt.Errorf("no medication linked to reminder found")
			}

			// calculate the new inventory
			new_inventory := medications[0].Inventory - medications[0].Dosage
			// if the inventory becomes negative, throw an error
			if new_inventory < 0 {
				return nil, fmt.Errorf("negative inventory")
			}

			// update the inventory
			_, err = database.DB.Query(
				`UPDATE ONLY $id SET inventory=$inventory`,
				map[string]interface{}{
					"id":        remBefore.MedicationID,
					"inventory": new_inventory,
				},
			)
			if err != nil {
				return nil, err
			}
		}
	}

	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": reminderID}

	// Prepare the fields to be updated
	updateFields := []string{}
	if reminderTime != nil {
		updateValues["reminder_time"] = *reminderTime
		updateFields = append(updateFields, "reminder_time = $reminder_time")
	}
	if isTaken != nil {
		updateValues["is_taken"] = *isTaken
		updateFields = append(updateFields, "is_taken = $is_taken")
	}

	// Construct the final query
	query := fmt.Sprintf("UPDATE $id SET %s;", strings.Join(updateFields, ", "))
	// send the UPDATE query
	result, err = database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// unmarshal results and construct response
	results, err := surrealdb.SmartUnmarshal[[]*model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}
	response := &model.UpdateMedicationReminderResponse{
		ReminderID: results[0].ID,
		Message:    "Medication reminder updated successfully",
	}

	return response, nil
}

// CreateTreatmentSchedule is the resolver for the createTreatmentSchedule field.
func (r *mutationResolver) CreateTreatmentSchedule(ctx context.Context, treatmentType string, scheduledTime string, location string, notes *string) (*model.CreateTreatmentScheduleResponse, error) {
	// 验证用户权限
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// 创建治疗计划记录
	result, err := database.DB.Query(
		`CREATE ONLY treatment_schedule:ulid()
        SET treatment_type=$treatment_type,
        scheduled_time=$scheduled_time,
        location=$location,
        notes=$notes,
        user_id=$user_id,
        created_at=time::now(),
        updated_at=time::now();`,
		map[string]interface{}{
			"treatment_type": treatmentType,
			"scheduled_time": scheduledTime,
			"location":       location,
			"notes":          notes,
			"user_id":        user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// 解析返回结果
	newSchedule, err := surrealdb.SmartUnmarshal[model.TreatmentSchedule](result, nil)
	if err != nil {
		return nil, err
	}
	response := &model.CreateTreatmentScheduleResponse{
		ScheduleID: newSchedule.ID,
		Message:    "Treatment schedule created successfully",
	}

	return response, nil
}

// UpdateTreatmentSchedule is the resolver for the updateTreatmentSchedule field.
func (r *mutationResolver) UpdateTreatmentSchedule(ctx context.Context, scheduleID string, treatmentType *string, scheduledTime *string, location *string, notes *string) (*model.UpdateTreatmentScheduleResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	if !utils.MatchID(scheduleID, "treatment_schedule") {
		return nil, fmt.Errorf("illegal schedule id")
	}

	// 准备更新字段
	updateValues := map[string]interface{}{
		"id":      scheduleID,
		"user_id": user.ID,
	}
	updateFields := []string{}

	if treatmentType != nil {
		updateValues["treatment_type"] = *treatmentType
		updateFields = append(updateFields, "treatment_type = $treatment_type")
	}
	if scheduledTime != nil {
		updateValues["scheduled_time"] = *scheduledTime
		updateFields = append(updateFields, "scheduled_time = $scheduled_time")
	}
	if location != nil {
		updateValues["location"] = *location
		updateFields = append(updateFields, "location = $location")
	}
	if notes != nil {
		updateValues["notes"] = *notes
		updateFields = append(updateFields, "notes = $notes")
	}
	updateFields = append(updateFields, "updated_at = time::now()")

	// 构建并执行更新查询
	query := fmt.Sprintf("UPDATE $id SET %s WHERE user_id = $user_id;", strings.Join(updateFields, ", "))
	result, err := database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// 验证更新结果
	schedules, err := surrealdb.SmartUnmarshal[[]model.TreatmentSchedule](result, nil)
	if err != nil {
		return nil, err
	}
	if len(schedules) == 0 {
		return nil, fmt.Errorf("invalid id. no associated treatment schedule found")
	}

	response := &model.UpdateTreatmentScheduleResponse{
		ScheduleID: schedules[0].ID,
		Message:    "Treatment schedule updated successfully",
	}

	return response, nil
}

// DeleteTreatmentSchedule is the resolver for the deleteTreatmentSchedule field.
func (r *mutationResolver) DeleteTreatmentSchedule(ctx context.Context, scheduleID string) (*model.DeleteTreatmentScheduleResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	if !utils.MatchID(scheduleID, "treatment_schedule") {
		return nil, fmt.Errorf("illegal schedule id")
	}

	// 执行删除操作
	result, err := database.DB.Query(
		`DELETE $id WHERE user_id = $user_id RETURN BEFORE;`,
		map[string]interface{}{
			"id":      scheduleID,
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// 验证删除结果
	schedules, err := surrealdb.SmartUnmarshal[[]model.TreatmentScheduleDetail](result, nil)
	if err != nil {
		return nil, err
	}
	if len(schedules) == 0 {
		return nil, fmt.Errorf("schedule not found or delete failed")
	}

	response := &model.DeleteTreatmentScheduleResponse{
		Message: fmt.Sprintf("Treatment schedule %s deleted successfully", scheduleID),
	}

	return response, nil
}

// GetMedications is the resolver for the getMedications field.
func (r *queryResolver) GetMedications(ctx context.Context) ([]*model.MedicationDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// query for all the medications associated with the user
	result, err := database.DB.Query(
		`SELECT * FROM medication WHERE user_id = $user_id;`,
		map[string]interface{}{
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	medications, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
	if err != nil {
		return nil, err
	}

	// loop through the medications, convert them into MedicationDetails, then return the converted list and nil
	var medicationDetails []*model.MedicationDetail
	for _, med := range medications {
		medicationDetail := &model.MedicationDetail{
			MedicationID: med.ID,
			Name:         med.Name,
			Dosage:       med.Dosage,
			Unit:         med.Unit,
			Frequency:    med.Frequency,
			Inventory:    med.Inventory,
		}
		medicationDetails = append(medicationDetails, medicationDetail)
	}

	return medicationDetails, nil
}

// GetMedicationReminders is the resolver for the getMedicationReminders field.
func (r *queryResolver) GetMedicationReminders(ctx context.Context) ([]*model.MedicationReminderDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// get all the medication reminders for the user
	result, err := database.DB.Query(
		`SELECT * FROM medication_reminder WHERE user_id = $user_id;`,
		map[string]interface{}{
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	reminders, err := surrealdb.SmartUnmarshal[[]model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}

	// loop through the reminders, convert them into MedicationReminderDetails, then return the converted list and nil
	var reminderDetails []*model.MedicationReminderDetail
	for _, rem := range reminders {
		reminderDetail := &model.MedicationReminderDetail{
			ReminderID:   rem.ID,
			MedicationID: rem.MedicationID,
			ReminderTime: rem.ReminderTime,
			IsTaken:      rem.IsTaken,
		}
		reminderDetails = append(reminderDetails, reminderDetail)
	}

	return reminderDetails, nil
}

// GetTreatmentSchedules is the resolver for the getTreatmentSchedules field.
func (r *queryResolver) GetTreatmentSchedules(ctx context.Context) ([]*model.TreatmentScheduleDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// Fetch treatment schedules for the user
	result, err := database.DB.Query(`SELECT * FROM treatment_schedule WHERE user_id=$userID;`, map[string]interface{}{
		"userID": user.ID,
	})
	if err != nil {
		return nil, err
	}

	// TODO: please modify this line as it may result in a bug
	schedules, err := surrealdb.SmartUnmarshal[[]*model.TreatmentScheduleDetail](result, nil)
	if err != nil {
		return nil, err
	}

	return schedules, nil
}
