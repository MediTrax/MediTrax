package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/chat"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"
	"strconv"
	"strings"
)

// GetFoodSpecs is the resolver for the getFoodSpecs field.
func (r *queryResolver) GetFoodSpecs(ctx context.Context, food string) (*model.FoodSpecs, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// client := chat.GetClient()

	// result, err := chat.GetFoodSpec(food, client)
	// if err != nil {
	// 	return nil, err
	// }

	// println(*result)
	client := chat.GetClientDeepSeek()

	result, err := chat.GetFoodSpecDeepSeek(food, client)
	if err != nil {
		return nil, err
	}

	println(*result)

	lines := strings.Split(*result, "\n")

	var specs []*model.FoodSpec
	var n_spec = 0.0
	var s_total = 0.0

	for _, line := range lines {
		line = strings.TrimSpace(line)

		parameters := strings.Split(line, ": ")
		if len(parameters) < 2 {
			continue
		}
		info := strings.Split(strings.TrimSpace(parameters[1]), " ")

		println(parameters[0] + parameters[1])
		println(info[0])

		value, err := strconv.ParseFloat(info[0], 32)
		if err != nil {
			continue
		}

		spec := &model.FoodSpec{
			Name:  parameters[0],
			Value: value,
			Unit:  info[1],
		}

		var valid_spec = false
		for _, spec_limit := range chat.SpecLimits {
			if spec.Name == spec_limit.Name {
				valid_spec = true
				spec.Name = spec_limit.ChineseName

				// if actual value is below recommended value, then make HowHigh<0.3 (displays as recommended)
				if value < spec_limit.Recommended {
					spec.HowHigh = 0.3 * value / spec_limit.Recommended
					s_total += spec.HowHigh
				} else {
					spec.HowHigh = 0.3 + 0.7*(value-spec_limit.Recommended)/spec_limit.Recommended
					s_total += min(1.5, spec.HowHigh)
					spec.HowHigh = min(1, spec.HowHigh)
				}

				n_spec = n_spec + 1
			}
		}

		if valid_spec {
			specs = append(specs, spec)
		}
	}

	foodSpecs := &model.FoodSpecs{
		Specs:        specs,
		HowRecommend: min(1, s_total/n_spec),
	}

	return foodSpecs, nil
}

// GetMockFoodSpecs is the resolver for the getMockFoodSpecs field.
func (r *queryResolver) GetMockFoodSpecs(ctx context.Context, food string) (*model.FoodSpecs, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	var specs []*model.FoodSpec
	for _, spec_limit := range chat.SpecLimits {
		specs = append(specs, &model.FoodSpec{Name: spec_limit.ChineseName, Value: spec_limit.Recommended / 2, Unit: "mock unit", HowHigh: 0.5})
	}

	foodSpecs := &model.FoodSpecs{
		Specs:        specs,
		HowRecommend: 0.5,
	}

	return foodSpecs, nil
}

// GetFoodRecommendation is the resolver for the getFoodRecommendation field.
func (r *queryResolver) GetFoodRecommendation(ctx context.Context) (*model.FoodRecommendation, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// client := chat.GetClient()

	// result, err := chat.GetFoodRecommend(client)
	// if err != nil {
	// 	return nil, err
	// }

	client := chat.GetClientDeepSeek()

	result, err := chat.GetFoodRecommendDeepSeek(client)
	if err != nil {
		return nil, err
	}

	println(*result)

	recommendation := &model.FoodRecommendation{
		Name: *result,
	}

	return recommendation, nil
}

// GetMockFoodRecommendation is the resolver for the getMockFoodRecommendation field.
func (r *queryResolver) GetMockFoodRecommendation(ctx context.Context) (*model.FoodRecommendation, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	recommendation := &model.FoodRecommendation{
		Name: "红薯",
	}

	return recommendation, nil
}
