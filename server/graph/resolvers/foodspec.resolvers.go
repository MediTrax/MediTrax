package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/chat"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"
	"strconv"
	"strings"
)

// GetFoodSpecs is the resolver for the getFoodSpecs field.
func (r *queryResolver) GetFoodSpecs(ctx context.Context, food string) (*model.FoodSpecs, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	client := chat.GetClient()

	result, err := chat.GetFoodSpec(food, client)
	if err != nil {
		return nil, err
	}

	println(*result)

	lines := strings.Split(*result, "\n")

	var specs []*model.FoodSpec
	var n_spec = 0.0
	var s_total = 0.0
	for _, line := range lines {
		line = strings.TrimSpace(line)

		parameters := strings.Split(line, ": ")
		info := strings.Split(strings.TrimSpace(parameters[1]), " ")

		println(parameters[0] + parameters[1])
		println(info[0])

		value, err := strconv.ParseFloat(info[0], 32)
		if err != nil {
			continue
		}

		spec := &model.FoodSpec{
			Name:  parameters[0],
			Value: value,
			Unit:  info[1],
		}

		var valid_spec = false
		for _, spec_limit := range chat.SpecLimits {
			if spec.Name == spec_limit.Name {
				valid_spec = true

				spec.HowHigh = min(1, value/spec_limit.UpperRange)
				n_spec = n_spec + 1
				s_total = s_total + value/spec_limit.UpperRange
				// if value > spec_limit.UpperRange {
				// 	spec.IsTooHigh = true
				// 	recommend = false
				// } else {
				// 	spec.IsTooHigh = false
				// }
			}
		}

		if valid_spec {
			specs = append(specs, spec)
		}
	}

	foodSpecs := &model.FoodSpecs{
		Specs:        specs,
		HowRecommend: min(1, s_total/n_spec),
	}

	return foodSpecs, nil
}

// GetMockFoodSpecs is the resolver for the getMockFoodSpecs field.
func (r *queryResolver) GetMockFoodSpecs(ctx context.Context, food string) (*model.FoodSpecs, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	var specs []*model.FoodSpec
	for _, spec_limit := range chat.SpecLimits {
		specs = append(specs, &model.FoodSpec{Name: spec_limit.Name, Value: spec_limit.UpperRange / 2})
	}

	foodSpecs := &model.FoodSpecs{
		Specs:        specs,
		HowRecommend: 0.5,
	}

	return foodSpecs, nil
}

// GetFoodRecommendation is the resolver for the getFoodRecommendation field.
func (r *queryResolver) GetFoodRecommendation(ctx context.Context) (*model.FoodRecommendation, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	client := chat.GetClient()

	result, err := chat.GetFoodRecommend(client)
	if err != nil {
		return nil, err
	}

	recommendation := &model.FoodRecommendation{
		Name: *result,
	}

	return recommendation, nil
}

// GetMockFoodRecommendation is the resolver for the getMockFoodRecommendation field.
func (r *queryResolver) GetMockFoodRecommendation(ctx context.Context) (*model.FoodRecommendation, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	recommendation := &model.FoodRecommendation{
		Name: "红薯",
	}

	return recommendation, nil
}
