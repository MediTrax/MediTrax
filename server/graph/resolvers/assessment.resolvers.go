package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/database"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"
	"meditrax/graph/utils"

	surrealdb "github.com/surrealdb/surrealdb.go"
)

// CreateHealthRiskAssessment is the resolver for the createHealthRiskAssessment field.
func (r *mutationResolver) CreateHealthRiskAssessment(ctx context.Context, questionnaireData string) (*model.HealthRiskAssessmentResponse, error) {
	//panic(fmt.Errorf("not implemented: UpdateHealthRiskAssessment - updateHealthRiskAssessment"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	riskLevel, recommendations := utils.EvaluateHealthRisk(questionnaireData)

	result, err := database.DB.Query(
		`CREATE ONLY health_risk_assessment:ulid()
		    SET
				user_id=$user_id,
				questionnaire_data=$questionnaireData,
		        risk_level=$riskLevel,
		        recommendations=$recommendations,
		        created_at=time::now();`,
		map[string]interface{}{
			"questionnaireData": questionnaireData,
			"riskLevel":         riskLevel,
			"recommendations":   recommendations,
			"user_id":           user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	newAssessment, err := surrealdb.SmartUnmarshal[model.HealthRiskAssessment](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.HealthRiskAssessmentResponse{
		AssessmentID:    newAssessment.ID,
		RiskLevel:       newAssessment.RiskLevel,
		Recommendations: newAssessment.Recommendations,
	}

	return response, nil
}

// EvaluateHealthRiskAssessment is the resolver for the evaluateHealthRiskAssessment field.
func (r *mutationResolver) EvaluateHealthRiskAssessment(ctx context.Context, filledQuestionnaire model.FilledQuestionnaire) (*model.EvaluateHealthRiskAssessmentResponse, error) {
	panic(fmt.Errorf("not implemented: EvaluateHealthRiskAssessment - evaluateHealthRiskAssessment"))
}

// GetHealthRiskAssessment is the resolver for the getHealthRiskAssessment field.
func (r *queryResolver) GetHealthRiskAssessment(ctx context.Context) (*model.HealthRiskAssessmentDetailResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 查询最新的健康风险评估（假设根据创建时间或其他条件进行排序）
	result, err := database.DB.Query(`SELECT * FROM health_risk_assessment ORDER BY created_at DESC LIMIT 1;`, nil)
	if err != nil {
		return nil, err
	}

	assessment, err := surrealdb.SmartUnmarshal[[]model.HealthRiskAssessment](result, nil)
	if err != nil {
		return nil, err
	}
	if len(assessment) == 0 {
		return nil, fmt.Errorf("invalid id. no associated assessment found")
	}
	detailResponse := &model.HealthRiskAssessmentDetailResponse{
		AssessmentID:      assessment[0].ID,
		QuestionnaireData: assessment[0].QuestionnaireData,
		RiskLevel:         assessment[0].RiskLevel,
		Recommendations:   assessment[0].Recommendations,
		CreatedAt:         assessment[0].CreatedAt,
	}

	return detailResponse, nil
}

// GetHealthRiskAssessmentQuestion is the resolver for the getHealthRiskAssessmentQuestion field.
func (r *queryResolver) GetHealthRiskAssessmentQuestion(ctx context.Context) (*model.QuestionnaireObject, error) {
	panic(fmt.Errorf("not implemented: GetHealthRiskAssessmentQuestion - getHealthRiskAssessmentQuestion"))
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) UpdateHealthRiskAssessment(ctx context.Context, assessmentID string, questionnaireData string) (*model.UpdateHealthRiskAssessmentResponse, error) {
	//panic(fmt.Errorf("not implemented: UpdateHealthRiskAssessment - updateHealthRiskAssessment"))
	//check if they are logged in correctly
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// check if id is legal
	if !utils.MatchID(assessmentID, "health_risk_assessment") {
		return nil, fmt.Errorf("illegal assessment id")
	}
	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{
		"id":      assessmentID,
		"user_id": user.ID,
	}

	// Prepare the fields to be updated
	updateFields := []string{}

	// Add questionnaire data if provided
	if questionnaireData != "" {
		updateValues["questionnaireData"] = questionnaireData
		updateFields = append(updateFields, "questionnaire_data=$questionnaireData")

		// Calculate new risk level and recommendations
		riskLevel, recommendations := utils.EvaluateHealthRisk(questionnaireData)
		updateValues["riskLevel"] = riskLevel
		updateFields = append(updateFields, "risk_level=$riskLevel")
		updateValues["recommendations"] = recommendations
		updateFields = append(updateFields,
			"recommendations = $recommendations",
		)
		// Add createdAt if needed
		createdAt := time.Now().Format(time.RFC3339) // Use current time or your logic
		updateValues["createdAt"] = createdAt
		updateFields = append(updateFields, "created_at=$createdAt")
	}

	// Construct the final query
	query := fmt.Sprintf("UPDATE $id SET %s WHERE user_id=$user_id RETURN *;",
		strings.Join(updateFields, ", "))

	// Send the UPDATE query
	result, err := database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// Unmarshal the results and check for errors
	results, err := surrealdb.SmartUnmarshal[[]model.HealthRiskAssessment](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id. no associated assessment found")
	}

	// Create response
	response := &model.UpdateHealthRiskAssessmentResponse{
		AssessmentID:    results[0].ID,
		RiskLevel:       results[0].RiskLevel,
		Recommendations: results[0].Recommendations,
	}

	return response, nil
}
*/
