package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/database"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"
	"meditrax/graph/utils"

	surrealdb "github.com/surrealdb/surrealdb.go"
)

// CreateHealthRiskAssessment is the resolver for the createHealthRiskAssessment field.
func (r *mutationResolver) CreateHealthRiskAssessment(ctx context.Context, questionnaireData string) (*model.HealthRiskAssessmentResponse, error) {
	//panic(fmt.Errorf("not implemented: UpdateHealthRiskAssessment - updateHealthRiskAssessment"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	riskLevel, recommendations := utils.EvaluateHealthRisk(questionnaireData)

	result, err := database.DB.Query(
		`CREATE ONLY health_risk_assessment:ulid()
		    SET
				user_id=$user_id,
				questionnaire_data=$questionnaireData,
		        risk_level=$riskLevel,
		        recommendations=$recommendations,
		        created_at=time::now();`,
		map[string]interface{}{
			"questionnaireData": questionnaireData,
			"riskLevel":         riskLevel,
			"recommendations":   recommendations,
			"user_id":           user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	newAssessment, err := surrealdb.SmartUnmarshal[model.HealthRiskAssessment](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.HealthRiskAssessmentResponse{
		AssessmentID:    newAssessment.ID,
		RiskLevel:       newAssessment.RiskLevel,
		Recommendations: newAssessment.Recommendations,
	}

	return response, nil
}

// 假设这是一个全局变量，用于生成递增的assessmentId
var assessmentIdCounter int = 1

// EvaluateHealthRiskAssessment 是处理填写问卷后健康评估的函数
func (r *mutationResolver) EvaluateHealthRiskAssessment(ctx context.Context, filledQuestionnaire model.FilledQuestionnaire) (*model.EvaluateHealthRiskAssessmentResponse, error) {
	// 生成assessmentId
	assessmentId := fmt.Sprintf("assessment-%d", assessmentIdCounter)
	assessmentIdCounter++ // 每次调用时递增ID

	// 假设一个简单的评估逻辑：根据用户回答的关键问题评估风险
	riskLevel := "低风险"
	recommendations := "保持健康的生活方式，定期检查"

	// 遍历用户的回答
	for _, response := range filledQuestionnaire.Responses {
		// 根据问题ID和答案进行简单的评估逻辑
		switch response.QuestionID {
		case 1: // 是否有高血压病史
			if response.Choice == "是" {
				riskLevel = "中风险"
				recommendations = "建议控制血压，定期检查"
			}
		case 2: // 是否有糖尿病病史
			if response.Choice == "是" {
				riskLevel = "高风险"
				recommendations = "建议控制血糖，定期进行肾功能检查"
			}
		case 3: // 是否有肾脏疾病相关症状（如水肿、尿频等）
			if response.Choice == "水肿" || response.Choice == "尿频" {
				riskLevel = "高风险"
				recommendations = "建议尽快就医检查肾功能"
			}
			// case 4: // 填写肾功能检查结果
			//     if response.Answer != "" {
			//         // 根据用户填写的检查结果进一步评估
			//         // 假设检查结果中，若肌酐超过一定值则提示高风险
			//         if strings.Contains(response.Answer, "肌酐高") {
			//             riskLevel = "高风险"
			//             recommendations = "建议尽早治疗，控制肾功能"
			//         }
			//     }
		}
	}

	// 返回评估结果
	return &model.EvaluateHealthRiskAssessmentResponse{
		AssessmentID:    assessmentId,
		RiskLevel:       riskLevel,
		Recommendations: recommendations,
	}, nil
}

// GetHealthRiskAssessment is the resolver for the getHealthRiskAssessment field.
func (r *queryResolver) GetHealthRiskAssessment(ctx context.Context) (*model.HealthRiskAssessmentDetailResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 查询最新的健康风险评估（假设根据创建时间或其他条件进行排序）
	result, err := database.DB.Query(`SELECT * FROM health_risk_assessment ORDER BY created_at DESC LIMIT 1;`, nil)
	if err != nil {
		return nil, err
	}

	assessment, err := surrealdb.SmartUnmarshal[[]model.HealthRiskAssessment](result, nil)
	if err != nil {
		return nil, err
	}
	if len(assessment) == 0 {
		return nil, fmt.Errorf("invalid id. no associated assessment found")
	}
	detailResponse := &model.HealthRiskAssessmentDetailResponse{
		AssessmentID:      assessment[0].ID,
		QuestionnaireData: assessment[0].QuestionnaireData,
		RiskLevel:         assessment[0].RiskLevel,
		Recommendations:   assessment[0].Recommendations,
		CreatedAt:         assessment[0].CreatedAt,
	}

	return detailResponse, nil
}

var questionnaireIdCounter int = 1

// GetHealthRiskAssessmentQuestion is the resolver for the getHealthRiskAssessmentQuestion field.
func (r *queryResolver) GetHealthRiskAssessmentQuestion(ctx context.Context) (*model.QuestionnaireObject, error) {
	questionnaireId := questionnaireIdCounter
	questionnaireIdCounter++ // 每次调用时递增ID

	questions := []*model.Question{
		{
			QuestionID:   1,
			Question:     "你是否有高血压病史？",
			QuestionType: 0, // 单选题
			Choices:      []string{"是", "否"},
		},
		{
			QuestionID:   2,
			Question:     "你是否有糖尿病病史？",
			QuestionType: 0, // 单选题
			Choices:      []string{"是", "否"},
		},
		{
			QuestionID:   3,
			Question:     "你是否有肾脏疾病相关症状（如水肿、尿频等）？",
			QuestionType: 1, // 多选题
			Choices:      []string{"水肿", "尿频", "腰痛", "无症状"},
		},
		// {
		// 	QuestionID:   4,
		// 	Question:     "请填写你最近的肾功能检查结果（如肌酐、尿蛋白等）",
		// 	QuestionType: 2,   // 填空题
		// 	Choices:      nil, // 填空题没有选项
		// },
	}

	// 返回QuestionnaireObject
	return &model.QuestionnaireObject{
		QuestionnaireID: questionnaireId, // 可以根据实际需要返回合适的ID
		Data:            questions,
	}, nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) UpdateHealthRiskAssessment(ctx context.Context, assessmentID string, questionnaireData string) (*model.UpdateHealthRiskAssessmentResponse, error) {
	//panic(fmt.Errorf("not implemented: UpdateHealthRiskAssessment - updateHealthRiskAssessment"))
	//check if they are logged in correctly
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// check if id is legal
	if !utils.MatchID(assessmentID, "health_risk_assessment") {
		return nil, fmt.Errorf("illegal assessment id")
	}
	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{
		"id":      assessmentID,
		"user_id": user.ID,
	}

	// Prepare the fields to be updated
	updateFields := []string{}

	// Add questionnaire data if provided
	if questionnaireData != "" {
		updateValues["questionnaireData"] = questionnaireData
		updateFields = append(updateFields, "questionnaire_data=$questionnaireData")

		// Calculate new risk level and recommendations
		riskLevel, recommendations := utils.EvaluateHealthRisk(questionnaireData)
		updateValues["riskLevel"] = riskLevel
		updateFields = append(updateFields, "risk_level=$riskLevel")
		updateValues["recommendations"] = recommendations
		updateFields = append(updateFields,
			"recommendations = $recommendations",
		)
		// Add createdAt if needed
		createdAt := time.Now().Format(time.RFC3339) // Use current time or your logic
		updateValues["createdAt"] = createdAt
		updateFields = append(updateFields, "created_at=$createdAt")
	}

	// Construct the final query
	query := fmt.Sprintf("UPDATE $id SET %s WHERE user_id=$user_id RETURN *;",
		strings.Join(updateFields, ", "))

	// Send the UPDATE query
	result, err := database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// Unmarshal the results and check for errors
	results, err := surrealdb.SmartUnmarshal[[]model.HealthRiskAssessment](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id. no associated assessment found")
	}

	// Create response
	response := &model.UpdateHealthRiskAssessmentResponse{
		AssessmentID:    results[0].ID,
		RiskLevel:       results[0].RiskLevel,
		Recommendations: results[0].Recommendations,
	}

	return response, nil
}
*/
