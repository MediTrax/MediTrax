package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/database"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"
	"meditrax/graph/utils"
<<<<<<< HEAD
	"strings"
	"time"

	surrealdb "github.com/surrealdb/surrealdb.go"
)

// CreateHealthRiskAssessment is the resolver for the createHealthRiskAssessment field.
func (r *mutationResolver) CreateHealthRiskAssessment(ctx context.Context, questionnaireData string) (*model.HealthRiskAssessmentResponse, error) {
	//panic(fmt.Errorf("not implemented: UpdateHealthRiskAssessment - updateHealthRiskAssessment"))
=======
	"time"

	"github.com/google/uuid"
	surrealdb "github.com/surrealdb/surrealdb.go"
)

// EvaluateHealthRiskAssessment is the resolver for the evaluateHealthRiskAssessment field.
func (r *mutationResolver) EvaluateHealthRiskAssessment(ctx context.Context, filledQuestionnaire model.FilledQuestionnaire) (*model.EvaluateHealthRiskAssessmentResponse, error) {
	//panic(fmt.Errorf("not implemented: EvaluateHealthRiskAssessment - evaluateHealthRiskAssessment"))
>>>>>>> 01096166741546756a9456fc584388602358902c
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

<<<<<<< HEAD
	riskLevel, recommendations := utils.EvaluateHealthRisk(questionnaireData)

	result, err := database.DB.Query(
		`CREATE ONLY health_risk_assessment:ulid()
		    SET
				user_id=$user_id,
				questionnaire_data=$questionnaireData,
		        risk_level=$riskLevel,
		        recommendations=$recommendations,
		        created_at=time::now();`,
		map[string]interface{}{
			"questionnaireData": questionnaireData,
			"riskLevel":         riskLevel,
			"recommendations":   recommendations,
			"user_id":           user.ID,
=======
	riskLevel, recommendations := utils.EvaluateHealthRisk(filledQuestionnaire.Responses)
	// create new HealthMetric record
	result, err := database.DB.Query(
		`CREATE ONLY health_assessment:ulid()
		SET
		userId=$userId,
		questionnaireData=$questionnaireData,
		riskLevel=$riskLevel,
		recommendations=$recommendations,
		createdAt=time::now();
		`,
		map[string]interface{}{
			"userId":            user.ID,
			"questionnaireData": filledQuestionnaire.Responses,
			"riskLevel":         riskLevel,
			"recommendations":   recommendations,
		},
	)
	if err != nil {
		return nil, err
	}
	newassessment, err := surrealdb.SmartUnmarshal[model.HealthRiskAssessment](result, nil)
	if err != nil {
		return nil, err
	}
	// create response
	response := &model.EvaluateHealthRiskAssessmentResponse{
		AssessmentID:    newassessment.ID,
		RiskLevel:       newassessment.RiskLevel,
		Recommendations: newassessment.Recommendations,
	}
	return response, nil
}

// GetHealthRiskAssessment is the resolver for the getHealthRiskAssessment field.
func (r *queryResolver) GetHealthRiskAssessment(ctx context.Context) ([]*model.HealthRiskAssessmentDetailResponse, error) {
	//panic(fmt.Errorf("not implemented: GetHealthRiskAssessment - getHealthRiskAssessment"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// query for all the medications associated with the user
	result, err := database.DB.Query(
		`SELECT * FROM health_assessment WHERE userId = $userId;`,
		map[string]interface{}{
			"userId": user.ID,
>>>>>>> 01096166741546756a9456fc584388602358902c
		},
	)
	if err != nil {
		return nil, err
	}

<<<<<<< HEAD
	newAssessment, err := surrealdb.SmartUnmarshal[model.HealthRiskAssessment](result, nil)
=======
	HealthRiskAssessment, err := surrealdb.SmartUnmarshal[[]model.HealthRiskAssessment](result, nil)
>>>>>>> 01096166741546756a9456fc584388602358902c
	if err != nil {
		return nil, err
	}

<<<<<<< HEAD
	response := &model.HealthRiskAssessmentResponse{
		AssessmentID:    newAssessment.ID,
		RiskLevel:       newAssessment.RiskLevel,
		Recommendations: newAssessment.Recommendations,
	}

	return response, nil
}

// UpdateHealthRiskAssessment is the resolver for the updateHealthRiskAssessment field.
func (r *mutationResolver) UpdateHealthRiskAssessment(ctx context.Context, assessmentID string, questionnaireData string) (*model.UpdateHealthRiskAssessmentResponse, error) {
	//panic(fmt.Errorf("not implemented: UpdateHealthRiskAssessment - updateHealthRiskAssessment"))
	//check if they are logged in correctly
=======
	// loop through the medications, convert them into MedicationDetails, then return the converted list and nil
	var AssessmentDetails []*model.HealthRiskAssessmentDetailResponse
	for _, ass := range HealthRiskAssessment {
		AssessmentDetail := &model.HealthRiskAssessmentDetailResponse{
			AssessmentID:      ass.ID,
			QuestionnaireData: ass.QuestionnaireData,
			RiskLevel:         ass.RiskLevel,
			Recommendations:   ass.Recommendations,
			CreatedAt:         ass.CreatedAt,
		}
		AssessmentDetails = append(AssessmentDetails, AssessmentDetail)
	}

	return AssessmentDetails, nil
}

// GetHealthRiskAssessmentQuestion is the resolver for the getHealthRiskAssessmentQuestion field.
func (r *queryResolver) GetHealthRiskAssessmentQuestion(ctx context.Context) (*model.QuestionnaireObject, error) {
>>>>>>> 01096166741546756a9456fc584388602358902c
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
<<<<<<< HEAD
	// check if id is legal
	if !utils.MatchID(assessmentID, "health_risk_assessment") {
		return nil, fmt.Errorf("illegal assessment id")
	}
	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{
		"id":      assessmentID,
		"user_id": user.ID,
	}

	// Prepare the fields to be updated
	updateFields := []string{}

	// Add questionnaire data if provided
	if questionnaireData != "" {
		updateValues["questionnaireData"] = questionnaireData
		updateFields = append(updateFields, "questionnaire_data=$questionnaireData")

		// Calculate new risk level and recommendations
		riskLevel, recommendations := utils.EvaluateHealthRisk(questionnaireData)
		updateValues["riskLevel"] = riskLevel
		updateFields = append(updateFields, "risk_level=$riskLevel")
		updateValues["recommendations"] = recommendations
		updateFields = append(updateFields,
			"recommendations = $recommendations",
		)
		// Add createdAt if needed
		createdAt := time.Now().Format(time.RFC3339) // Use current time or your logic
		updateValues["createdAt"] = createdAt
		updateFields = append(updateFields, "created_at=$createdAt")
	}

	// Construct the final query
	query := fmt.Sprintf("UPDATE $id SET %s WHERE user_id=$user_id RETURN *;",
		strings.Join(updateFields, ", "))

	// Send the UPDATE query
	result, err := database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// Unmarshal the results and check for errors
	results, err := surrealdb.SmartUnmarshal[[]model.HealthRiskAssessment](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id. no associated assessment found")
	}

	// Create response
	response := &model.UpdateHealthRiskAssessmentResponse{
		AssessmentID:    results[0].ID,
		RiskLevel:       results[0].RiskLevel,
		Recommendations: results[0].Recommendations,
	}

	return response, nil
}

// GetHealthRiskAssessment is the resolver for the getHealthRiskAssessment field.
func (r *queryResolver) GetHealthRiskAssessment(ctx context.Context) (*model.HealthRiskAssessmentDetailResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 查询最新的健康风险评估（假设根据创建时间或其他条件进行排序）
	result, err := database.DB.Query(`SELECT * FROM health_risk_assessment ORDER BY created_at DESC LIMIT 1;`, nil)
	if err != nil {
		return nil, err
	}

	assessment, err := surrealdb.SmartUnmarshal[[]model.HealthRiskAssessment](result, nil)
	if err != nil {
		return nil, err
	}
	if len(assessment) == 0 {
		return nil, fmt.Errorf("invalid id. no associated assessment found")
	}
	detailResponse := &model.HealthRiskAssessmentDetailResponse{
		AssessmentID:      assessment[0].ID,
		QuestionnaireData: assessment[0].QuestionnaireData,
		RiskLevel:         assessment[0].RiskLevel,
		Recommendations:   assessment[0].Recommendations,
		CreatedAt:         assessment[0].CreatedAt,
	}

	return detailResponse, nil
}
=======

	questionnaireId := uuid.New().String()
	// 返回完整的问卷问题
	questions := []*model.Question{
		{QuestionID: 1, Question: "您是否有高血压病史？", QuestionType: 0, Choices: []string{"是", "否"}},
		{QuestionID: 2, Question: "您是否有糖尿病病史？", QuestionType: 0, Choices: []string{"是", "否"}},
		{QuestionID: 3, Question: "您是否有家族肾病史？", QuestionType: 0, Choices: []string{"是", "否"}},
		{QuestionID: 4, Question: "您的年龄是多少？", QuestionType: 0, Choices: []string{"是", "否"}},
		{QuestionID: 5, Question: "您是否有水肿、尿频、尿急等排尿异常症状？", QuestionType: 0, Choices: []string{"是", "否"}},
		{QuestionID: 6, Question: "您的体重是否过重（BMI大于25）？", QuestionType: 0, Choices: []string{"是", "否"}},
		{QuestionID: 7, Question: "您是否有长期使用肾毒性药物的历史？", QuestionType: 0, Choices: []string{"是", "否"}},
		{QuestionID: 8, Question: "您最近一次的尿检结果是否显示尿蛋白或血尿？", QuestionType: 0, Choices: []string{"是", "否"}},
		{QuestionID: 9, Question: "您是否经常感到疲劳、虚弱？", QuestionType: 0, Choices: []string{"是", "否"}},
		{QuestionID: 10, Question: "您是否有过肾功能衰竭或其他严重肾脏问题的诊断记录？", QuestionType: 0, Choices: []string{"是", "否"}},
	}

	result, err := database.DB.Query(
		`CREATE ONLY questionnare_object:ulid()
		SET
		questionnaireId=$questionnaireId,
		data=$data,
		createdAt=time::now();`,
		map[string]interface{}{
			"questionnaire_id": questionnaireId,
			"data":             questions,
			"createdAt":        time.Now(),
		},
	)
	if err != nil {
		return nil, fmt.Errorf("failed to insert questionnaire into database: %v", err)
	}

	// 使用 SmartUnmarshal 将数据库返回的数据解析到模型中
	newquestionnaire, err := surrealdb.SmartUnmarshal[model.QuestionnaireObject](result, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal questionnaire data: %v", err)
	}
	response := &model.QuestionnaireObject{
		QuestionnaireID: newquestionnaire.QuestionnaireID,
		Data:            newquestionnaire.Data,
	}

	// 返回问卷对象
	return response, nil
}
>>>>>>> 01096166741546756a9456fc584388602358902c
