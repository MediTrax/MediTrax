package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/database"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"
	"meditrax/graph/utils"
	"strings"

	surrealdb "github.com/surrealdb/surrealdb.go"
)

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, accessToken string, refreshToken string, device string) (*model.Token, error) {
	panic(fmt.Errorf("not implemented: RefreshToken - refreshToken"))
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, phoneNumber string, password string, username string, role string) (*model.CreateUserResponse, error) {
	// panic(fmt.Errorf("waiting to be implemented"))
	// Check for unique phoneNumber and username
	result, err := database.DB.Query(`
	SELECT * FROM user WHERE name=$name OR phoneNumber=$phoneNumber;`, map[string]interface{}{
		"name":        username,
		"phoneNumber": phoneNumber,
	})

	if err != nil {
		return nil, err
	}
	//check the result of the query
	users, err := surrealdb.SmartUnmarshal[[]model.User](result, nil)
	if err != nil {
		return nil, err
	}
	if len(users) > 0 {
		return nil, fmt.Errorf("phoneNumber and username should be unique")
	}

	// Create the new user
	result, err = database.DB.Query(
		`CREATE ONLY user:ulid()
		SET name=$username,
		phoneNumber=$phoneNumber,
		password=crypto::argon2::generate($password),
		role=$role,
		createdAt=time::now(),
		updatedAt=time::now();`, map[string]interface{}{
			"username":    username,
			"phoneNumber": phoneNumber,
			"password":    password,
			"role":        role,
		})
	if err != nil {
		return nil, err
	}

	newUser, err := surrealdb.SmartUnmarshal[model.User](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.CreateUserResponse{
		UserID:  newUser.ID,
		Message: fmt.Sprintf("User %s created successfully", newUser.Name),
	}

	return response, nil
}

// LoginUser is the resolver for the loginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, phoneNumber string, password string) (*model.LoginUserResponse, error) {
	//panic(fmt.Errorf("waiting to be implemented"))
	// // Fetch the user based on phone number
	result, err := database.DB.Query(`SELECT * FROM user WHERE phoneNumber=$phoneNumber AND crypto::argon2::compare(password, $pass);`, map[string]interface{}{
		"phoneNumber": phoneNumber,
		"pass":        password,
	})
	if err != nil {
		return nil, err
	}

	users, err := surrealdb.SmartUnmarshal[[]model.User](result, nil)
	if err != nil {
		return nil, err
	}
	if len(users) <= 0 {
		return nil, fmt.Errorf("user not found")
	}

	user := users[0]
	if user.Password == "" {
		return nil, fmt.Errorf("user not available for password sign in, use other sign in methods instead")
	}

	token, err := utils.HandleLogin(&user, ctx)
	if err != nil {
		return nil, err
	}

	response := &model.LoginUserResponse{
		UserID:  user.ID,
		Token:   token,
		Message: "Login successful",
	}

	result, err = database.DB.Query(
		`UPDATE $user_id SET last_login=time::now();`, map[string]interface{}{
			"user_id": user.ID,
		})
	if err != nil {
		return nil, err
	}

	return response, nil
}

// GetUser is the resolver for the getUser field.
func (r *mutationResolver) GetUser(ctx context.Context) (*model.UserDetailResponse, error) {
	// Fetch the user details
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	response := &model.UserDetailResponse{
		UserID:      user.ID,
		PhoneNumber: user.PhoneNumber,
		Name:        user.Name,
		Role:        user.Role,
		CreatedAt:   user.CreatedAt,
		LastLogin:   &user.LastLogin,
	}
	return response, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, name *string, phoneNumber *string, password *string) (*model.UpdateUserResponse, error) {
	// check if the user is registed
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// 初始化更新值map
	updateValues := map[string]interface{}{"id": user.ID}

	// 准备需要更新的字段
	updateFields := []string{}

	if name != nil {
		updateValues["name"] = *name
		updateFields = append(updateFields, "name = $name")
	}

	if phoneNumber != nil {
		// TODO:可以添加电话号码格式验证
		updateValues["phone_number"] = *phoneNumber
		updateFields = append(updateFields, "phone_number = $phone_number")
	}

	if password != nil {
		updateValues["password"] = password
		updateFields = append(updateFields, "password = $password")
	}

	// 如果没有要更新的字段，返回错误
	if len(updateFields) == 0 {
		return nil, fmt.Errorf("no fields to update")
	}

	// 构造更新查询
	query := fmt.Sprintf("UPDATE $id SET %s;", strings.Join(updateFields, ", "))

	// 执行更新查询
	result, err := database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// 解析结果
	results, err := surrealdb.SmartUnmarshal[[]model.User](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("user not found")
	}

	// 创建响应
	response := &model.UpdateUserResponse{
		UserID:  results[0].ID,
		Message: "User updated successfully",
	}

	return response, nil

}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context) (*model.DeleteUserResponse, error) {
	// 检查用户是否已登录
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// 执行删除查询，RETURN BEFORE 会返回删除前的用户数据
	result, err := database.DB.Query(
		`DELETE $id RETURN BEFORE;`,
		map[string]interface{}{
			"id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// 解析结果并检查错误
	results, err := surrealdb.SmartUnmarshal[[]model.User](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("user not found")
	}

	// 创建响应
	response := &model.DeleteUserResponse{
		Message: fmt.Sprintf("User %s with name %s deleted successfully", results[0].ID, results[0].Name),
	}

	return response, nil
}

// RequestPasswordReset is the resolver for the requestPasswordReset field.
func (r *mutationResolver) RequestPasswordReset(ctx context.Context, phoneNumber string) (*model.RequestPasswordResetResponse, error) {
	result, err := database.DB.Query(`
    SELECT * FROM user WHERE phone_number=$phone_number;`,
		map[string]interface{}{
			"phone_number": phoneNumber,
		})
	if err != nil {
		return nil, err
	}

	users, err := surrealdb.SmartUnmarshal[[]model.User](result, nil)
	if err != nil {
		return nil, err
	}
	if len(users) <= 0 {
		return nil, fmt.Errorf("user not found")
	}

	// 创建密码重置请求
	result2, err := database.DB.Query(
		`CREATE ONLY passwordChange:ulid() SET userId=$userId;`,
		map[string]interface{}{
			"userId": users[0].ID,
		})
	if err != nil {
		return nil, err
	}

	results2, err := surrealdb.SmartUnmarshal[model.PasswordChange](result2, nil)
	if err != nil {
		return nil, err
	}

	// 获取重置码
	resetCode := strings.Split(results2.ID, ":")[1]

	// TODO: 在这里实现发送短信的逻辑
	// 暂时只返回成功消息，实际项目中需要集成短信服务

	// 创建响应
	response := &model.RequestPasswordResetResponse{
		Message: fmt.Sprintf("Password reset code %s has been sent to your phone %s", resetCode, phoneNumber),
	}

	return response, nil
}

// ResetPassword is the resolver for the resetPassword field.
func (r *mutationResolver) ResetPassword(ctx context.Context, token string, newPassword string) (*model.ResetPasswordResponse, error) {
	// Retrieve password reset request using the token
	data, err := database.DB.Select("passwordChange:" + token)
	if err != nil {
		// Token not found or an error occurred
		return nil, fmt.Errorf("invalid or expired token")
	}
	passwordReset, err := surrealdb.SmartUnmarshal[model.PasswordChange](data, nil)
	if err != nil {
		// Unmarshal error, invalid data
		return nil, fmt.Errorf("invalid token data")
	}

	// Update the user's password in the database
	_, err = database.DB.Query("UPDATE $id SET password=crypto::argon2::generate($password);", map[string]interface{}{
		"id":       passwordReset.User,
		"password": newPassword,
	})
	if err != nil {
		// Database query failed
		return nil, fmt.Errorf("failed to reset password: %v", err)
	}

	// Return success message
	return &model.ResetPasswordResponse{
		Message: "Password reset successfully",
	}, nil
}

// evaluateHealthRisk 根据问卷数据计算健康风险等级和推荐措施
func evaluateHealthRisk(questionnaireData string) (string, string) {
	// 假设这里是根据问卷数据进行风险评估和推荐生成的逻辑
	var riskLevel, recommendations string
	if questionnaireData == "" {
		riskLevel = "Unknown"
		recommendations = "Please complete the health questionnaire."
	} else {
		// 简单的例子，实际应根据数据分析
		riskLevel = "Medium"
		recommendations = "Monitor lifestyle and consult a healthcare provider."
	}
	return riskLevel, recommendations
}

// CreateHealthRiskAssessment is the resolver for the createHealthRiskAssessment field.
func (r *mutationResolver) CreateHealthRiskAssessment(ctx context.Context, questionnaireData string) (*model.HealthRiskAssessmentResponse, error) {
	//panic(fmt.Errorf("not implemented: CreateHealthRiskAssessment - createHealthRiskAssessment"))
	// check if they are logged in correctly
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// TODO:计算健康风险等级和推荐措施（假设基于问卷数据进行分析）
	riskLevel, recommendations := evaluateHealthRisk(questionnaireData)

	// 插入新的健康风险评估记录
	result, err := database.DB.Query(
		`CREATE ONLY health_risk_assessment:ulid() 
        SET questionnaireData=$questionnaireData,
            riskLevel=$riskLevel,
            recommendations=$recommendations,
            createdAt=time::now(),
            updatedAt=time::now();`,
		map[string]interface{}{
			"questionnaireData": questionnaireData,
			"riskLevel":         riskLevel,
			"recommendations":   recommendations,
		},
	)
	if err != nil {
		return nil, err
	}

	newAssessment, err := surrealdb.SmartUnmarshal[model.HealthRiskAssessmentResponse](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.HealthRiskAssessmentResponse{
		AssessmentID:    newAssessment.AssessmentID,
		RiskLevel:       newAssessment.RiskLevel,
		Recommendations: newAssessment.Recommendations,
	}

	return response, nil
}

// UpdateHealthRiskAssessment is the resolver for the updateHealthRiskAssessment field.
func (r *mutationResolver) UpdateHealthRiskAssessment(ctx context.Context, assessmentID string, questionnaireData string) (*model.UpdateHealthRiskAssessmentResponse, error) {
	//panic(fmt.Errorf("not implemented: UpdateHealthRiskAssessment - updateHealthRiskAssessment"))
	// check if they are logged in correctly
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// TODO:计算新的健康风险等级和推荐措施（假设基于问卷数据进行分析）
	riskLevel, recommendations := evaluateHealthRisk(questionnaireData)

	// 更新健康风险评估记录
	result, err := database.DB.Query(
		`UPDATE health_risk_assessment 
        SET questionnaireData=$questionnaireData,
            riskLevel=$riskLevel,
            recommendations=$recommendations,
            updatedAt=time::now() 
        WHERE id=$id;`,
		map[string]interface{}{
			"questionnaireData": questionnaireData,
			"riskLevel":         riskLevel,
			"recommendations":   recommendations,
			"id":                assessmentID,
		},
	)
	if err != nil {
		return nil, err
	}

	updatedAssessment, err := surrealdb.SmartUnmarshal[model.UpdateHealthRiskAssessmentResponse](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.UpdateHealthRiskAssessmentResponse{
		AssessmentID:    updatedAssessment.AssessmentID,
		RiskLevel:       updatedAssessment.RiskLevel,
		Recommendations: updatedAssessment.Recommendations,
	}

	return response, nil
}

// AddMedication is the resolver for the addMedication field.
func (r *mutationResolver) AddMedication(ctx context.Context, name string, dosage float64, unit string, frequency string, inventory float64) (*model.AddMedicationResponse, error) {
	// check if they are logged in correctly
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// query database for medications for the same user with the same name
	result, err := database.DB.Query(
		`SELECT * FROM medication WHERE name=$name AND user_id=$user_id;`,
		map[string]interface{}{
			"name":    name,
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	println("Finished query")
	medications, err := surrealdb.SmartUnmarshal[[]*model.Medication](result, nil)
	if err != nil {
		return nil, err
	}

	println("Finished unmarshaling medications")
	if len(medications) > 0 {
		return nil, fmt.Errorf("identical medication name already exists for the user, please use update medication instead")
	}

	// check the validity of the given frequency
	if _, _, err := utils.FrequencyParser(frequency); err != nil {
		return nil, fmt.Errorf("invalid frequency format %s for medication %s", frequency, name)
	}

	// create new Medication record
	result, err = database.DB.Query(
		`CREATE ONLY medication:ulid()
		SET name=$name,
		dosage=$dosage,
		unit=$unit,
		frequency=$frequency,
		inventory=$inventory,
		user_id=$user_id,
		created_at=time::now(),
		updated_at=time::now();
		`,
		map[string]interface{}{
			"name":      name,
			"dosage":    dosage,
			"unit":      unit,
			"frequency": frequency,
			"inventory": inventory,
			"user_id":   user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshall the returned results
	newMedication, err := surrealdb.SmartUnmarshal[model.Medication](result, nil)
	if err != nil {
		return nil, err
	}
	// create response
	response := &model.AddMedicationResponse{
		MedicationID: newMedication.ID,
		Message:      fmt.Sprintf("Medication %s added successfully", newMedication.Name),
	}

	return response, nil
}

// UpdateMedication is the resolver for the updateMedication field.
func (r *mutationResolver) UpdateMedication(ctx context.Context, medicationID string, name *string, dosage *float64, unit *string, frequency *string, inventory *float64) (*model.UpdateMedicationResponse, error) {
	// check if they are logged in correctly
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check if id is legal
	if !utils.MatchID(medicationID, "medication") {
		return nil, fmt.Errorf("illegal medication id")
	}

	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": medicationID, "user_id": user.ID}

	// Prepare the fields to be updated
	updateFields := []string{}
	if name != nil {
		updateValues["name"] = *name
		updateFields = append(updateFields, "name = $name")
	}
	if dosage != nil {
		updateValues["dosage"] = *dosage
		updateFields = append(updateFields, "dosage = $dosage")
	}
	if unit != nil {
		updateValues["unit"] = *unit
		updateFields = append(updateFields, "unit = $unit")
	}
	if frequency != nil {
		// Validate the frequency format
		if _, _, err := utils.FrequencyParser(*frequency); err != nil {
			return nil, err // Return the error if format is invalid
		}
		updateValues["frequency"] = *frequency
		updateFields = append(updateFields, "frequency = $frequency")
	}
	if inventory != nil {
		updateValues["inventory"] = *inventory
		updateFields = append(updateFields, "inventory = $inventory")
	}

	// Construct the final query with the medicationID in quotes
	query := fmt.Sprintf("UPDATE $id SET %s WHERE user_id=$user_id;", strings.Join(updateFields, ", "))

	// send the UPDATE query
	result, err := database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// unmarshal the results and check for errors
	results, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id. no associated medication object found")
	}

	// create response
	response := &model.UpdateMedicationResponse{
		MedicationID: results[0].ID,
		Message:      "Medication updated successfully",
	}

	// Return the response with the medication ID and a success message
	return response, nil
}

// DeleteMedication is the resolver for the deleteMedication field.
func (r *mutationResolver) DeleteMedication(ctx context.Context, medicationID string) (*model.DeleteMedicationResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check legality of the provided id
	if !utils.MatchID(medicationID, "medication") {
		return nil, fmt.Errorf("illegal medication id")
	}

	// Execute the query
	result, err := database.DB.Query(
		`DELETE $id WHERE user_id=$user_id RETURN BEFORE;`,
		map[string]interface{}{
			"id":      medicationID,
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err // Return the error if the query fails
	}

	// unmarshal results and check for errors
	results, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no associated medication object found")
	}

	// create response
	response := &model.DeleteMedicationResponse{
		Message: fmt.Sprintf("Medication %s with name %s deleted successfully", results[0].ID, results[0].Name),
	}

	// Return the response with the medication ID and a success message
	return response, nil
}

// CreateMedicationReminder is the resolver for the createMedicationReminder field.
func (r *mutationResolver) CreateMedicationReminder(ctx context.Context, medicationID string, reminderTime string) (*model.CreateMedicationReminderResponse, error) {
	// check legality of both user and medication id
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	if !utils.MatchID(medicationID, "medication") {
		return nil, fmt.Errorf("illegal medication id")
	}

	// query for the medication and check if it exists
	result, err := database.DB.Query(
		`SELECT * FROM $medication_id WHERE user_id = $user_id;`,
		map[string]interface{}{
			"medication_id": medicationID,
			"user_id":       user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	medications, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
	if err != nil {
		return nil, err
	}
	if len(medications) < 1 {
		return nil, fmt.Errorf("invalid medication id or medication id not associated with user")
	}

	// query database for medications with the same reminder time
	result, err = database.DB.Query(
		`SELECT * FROM medication_reminder 
		WHERE medication_id=$medication_id AND user_id=$user_id AND reminder_time=$reminder_time;`,
		map[string]interface{}{
			"medication_id": medicationID,
			"user_id":       user.ID,
			"reminder_time": reminderTime,
		},
	)
	if err != nil {
		return nil, err
	}
	reminders, err := surrealdb.SmartUnmarshal[[]model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}
	if len(reminders) > 0 {
		return nil, fmt.Errorf("identical medication reminder for the user already exists")
	}

	// finally, send the create reminder query
	result, err = database.DB.Query(
		`CREATE ONLY medication_reminder:ulid()
		SET medication_id=$medication_id,
		user_id=$user_id,
		reminder_time=$reminder_time,
		is_taken=false,
		created_at=time::now()
		`,
		map[string]interface{}{
			"medication_id": medicationID,
			"user_id":       user.ID,
			"reminder_time": reminderTime,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshal the results of the CREATE query
	newReminder, err := surrealdb.SmartUnmarshal[model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}

	// create response
	response := &model.CreateMedicationReminderResponse{
		ReminderID: newReminder.ID,
		Message:    "new reminder created successfully",
	}
	return response, nil
}

// UpdateMedicationReminder is the resolver for the updateMedicationReminder field.
func (r *mutationResolver) UpdateMedicationReminder(ctx context.Context, reminderID string, reminderTime *string, isTaken *bool) (*model.UpdateMedicationReminderResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check legality of the reminder id
	if !utils.MatchID(reminderID, "medication_reminder") {
		return nil, fmt.Errorf("illegal reminder id")
	}

	// query database to see if the reminder exists
	result, err := database.DB.Query(
		`SELECT * FROM medication_reminder WHERE id=$reminder_id AND user_id=$user_id;`,
		map[string]interface{}{
			"reminder_id": reminderID,
			"user_id":     user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	reminders, err := surrealdb.SmartUnmarshal[[]model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}
	if len(reminders) < 1 {
		return nil, fmt.Errorf("wrong medication reminder id, no reminder found")
	}

	// get the reminder before updating
	remBefore := reminders[0]

	// logic for when the reminder changes from not taken to taken, subtract the medication's remaining by its dosage
	if isTaken != nil {
		if !remBefore.IsTaken && *isTaken {
			result, err = database.DB.Query(
				`SELECT * FROM medication WHERE id=$med_id;`,
				map[string]interface{}{
					"med_id": remBefore.MedicationID,
				},
			)

			if err != nil {
				return nil, err
			}

			// verify that there is a medication linked to this reminder
			medications, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
			if err != nil {
				return nil, err
			}
			if len(medications) == 0 {
				return nil, fmt.Errorf("no medication linked to reminder found")
			}

			// calculate the new inventory
			new_inventory := medications[0].Inventory - medications[0].Dosage
			// if the inventory becomes negative, throw an error
			if new_inventory < 0 {
				return nil, fmt.Errorf("negative inventory")
			}

			// update the inventory
			_, err = database.DB.Query(
				`UPDATE ONLY $id SET inventory=$inventory`,
				map[string]interface{}{
					"id":        remBefore.MedicationID,
					"inventory": new_inventory,
				},
			)
			if err != nil {
				return nil, err
			}
		}
	}

	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": reminderID}

	// Prepare the fields to be updated
	updateFields := []string{}
	if reminderTime != nil {
		updateValues["reminder_time"] = *reminderTime
		updateFields = append(updateFields, "reminder_time = $reminder_time")
	}
	if isTaken != nil {
		updateValues["is_taken"] = *isTaken
		updateFields = append(updateFields, "is_taken = $is_taken")
	}

	// Construct the final query
	query := fmt.Sprintf("UPDATE $id SET %s;", strings.Join(updateFields, ", "))
	// send the UPDATE query
	result, err = database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// unmarshal results and construct response
	results, err := surrealdb.SmartUnmarshal[[]*model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}
	response := &model.UpdateMedicationReminderResponse{
		ReminderID: results[0].ID,
		Message:    "Medication reminder updated successfully",
	}

	return response, nil
}

// CreateTreatmentSchedule is the resolver for the createTreatmentSchedule field.
func (r *mutationResolver) CreateTreatmentSchedule(ctx context.Context, treatmentType string, scheduledTime string, location string, notes *string) (*model.CreateTreatmentScheduleResponse, error) {
	// 验证用户权限
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// 创建治疗计划记录
	result, err := database.DB.Query(
		`CREATE ONLY treatment_schedule:ulid()
        SET treatment_type=$treatment_type,
        scheduled_time=$scheduled_time,
        location=$location,
        notes=$notes,
        user_id=$user_id,
        created_at=time::now(),
        updated_at=time::now();`,
		map[string]interface{}{
			"treatment_type": treatmentType,
			"scheduled_time": scheduledTime,
			"location":       location,
			"notes":          notes,
			"user_id":        user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// 解析返回结果
	newSchedule, err := surrealdb.SmartUnmarshal[model.TreatmentScheduleDetail](result, nil)
	if err != nil {
		return nil, err
	}
	response := &model.CreateTreatmentScheduleResponse{
		ScheduleID: newSchedule.ScheduleID,
		Message:    "Treatment schedule created successfully",
	}

	return response, nil
}

// GetTreatmentSchedules is the resolver for the getTreatmentSchedules field.
func (r *mutationResolver) GetTreatmentSchedules(ctx context.Context) ([]*model.TreatmentScheduleDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// 查询该用户的所有治疗计划
	result, err := database.DB.Query(
		`SELECT * FROM treatment_schedule WHERE user_id = $user_id ORDER BY scheduled_time;`,
		map[string]interface{}{
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	schedules, err := surrealdb.SmartUnmarshal[[]*model.TreatmentScheduleDetail](result, nil)
	if err != nil {
		return nil, err
	}

	return schedules, nil
}

// UpdateTreatmentSchedule is the resolver for the updateTreatmentSchedule field.
func (r *mutationResolver) UpdateTreatmentSchedule(ctx context.Context, scheduleID string, treatmentType *string, scheduledTime *string, location *string, notes *string) (*model.UpdateTreatmentScheduleResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	if !utils.MatchID(scheduleID, "treatment_schedule") {
		return nil, fmt.Errorf("illegal schedule id")
	}

	// 准备更新字段
	updateValues := map[string]interface{}{"id": scheduleID, "user_id": user.ID}
	updateFields := []string{}

	if treatmentType != nil {
		updateValues["treatment_type"] = *treatmentType
		updateFields = append(updateFields, "treatment_type = $treatment_type")
	}
	if scheduledTime != nil {
		updateValues["scheduled_time"] = *scheduledTime
		updateFields = append(updateFields, "scheduled_time = $scheduled_time")
	}
	if location != nil {
		updateValues["location"] = *location
		updateFields = append(updateFields, "location = $location")
	}
	if notes != nil {
		updateValues["notes"] = *notes
		updateFields = append(updateFields, "notes = $notes")
	}
	updateFields = append(updateFields, "updated_at = time::now()")

	// 构建并执行更新查询
	query := fmt.Sprintf("UPDATE $id SET %s WHERE user_id = $user_id;", strings.Join(updateFields, ", "))
	result, err := database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// 验证更新结果
	schedules, err := surrealdb.SmartUnmarshal[[]model.TreatmentScheduleDetail](result, nil)
	if err != nil {
		return nil, err
	}
	if len(schedules) == 0 {
		return nil, fmt.Errorf("schedule not found or update failed")
	}

	response := &model.UpdateTreatmentScheduleResponse{
		ScheduleID: schedules[0].ScheduleID,
		Message:    "Treatment schedule updated successfully",
	}

	return response, nil
}

// DeleteTreatmentSchedule is the resolver for the deleteTreatmentSchedule field.
func (r *mutationResolver) DeleteTreatmentSchedule(ctx context.Context, scheduleID string) (*model.DeleteTreatmentScheduleResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	if !utils.MatchID(scheduleID, "treatment_schedule") {
		return nil, fmt.Errorf("illegal schedule id")
	}

	// 执行删除操作
	result, err := database.DB.Query(
		`DELETE $id WHERE user_id = $user_id RETURN BEFORE;`,
		map[string]interface{}{
			"id":      scheduleID,
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// 验证删除结果
	schedules, err := surrealdb.SmartUnmarshal[[]model.TreatmentScheduleDetail](result, nil)
	if err != nil {
		return nil, err
	}
	if len(schedules) == 0 {
		return nil, fmt.Errorf("schedule not found or delete failed")
	}

	response := &model.DeleteTreatmentScheduleResponse{
		Message: fmt.Sprintf("Treatment schedule %s deleted successfully", scheduleID),
	}

	return response, nil
}

// AddHealthMetric is the resolver for the addHealthMetric field.
func (r *mutationResolver) AddHealthMetric(ctx context.Context, metricType string, value float64, unit string, recordedAt string) (*model.AddHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check that there isn't already a metric entry for the user with the same type and record time
	result, err := database.DB.Query(
		`SELECT * FROM health_metric WHERE user_id=$user_id AND recorded_at=$recordedAt AND metric_type=$metricType;`,
		map[string]interface{}{
			"user_id":    user.ID,
			"recordedAt": recordedAt,
			"metricType": metricType,
		},
	)
	if err != nil {
		return nil, err
	}
	metrics, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(metrics) > 0 {
		return nil, fmt.Errorf("health metric with the same type and same recordAt time already exists")
	}

	// create new HealthMetric record
	result, err = database.DB.Query(
		`CREATE ONLY health_metric:ulid()
		SET
		user_id=$user_id,
		metric_type=$metric_type,
		value=$value,
		unit=$unit,
		recorded_at=$recorded_at,
		created_at=time::now();
		`,
		map[string]interface{}{
			"user_id":     user.ID,
			"metric_type": metricType,
			"value":       value,
			"unit":        unit,
			"recorded_at": recordedAt,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshall the returned results
	newMetric, err := surrealdb.SmartUnmarshal[model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	response := &model.AddHealthMetricResponse{
		MetricID: newMetric.ID,
		Message:  "new health metric added successfully",
	}

	return response, nil
}

// UpdateHealthMetric is the resolver for the updateHealthMetric field.
func (r *mutationResolver) UpdateHealthMetric(ctx context.Context, metricID string, value *float64, unit *string) (*model.UpdateHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check legality of the health metric id
	if !utils.MatchID(metricID, "health_metric") {
		return nil, fmt.Errorf("illegal health metric id")
	}

	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": metricID, "user_id": user.ID}

	// Prepare the fields to be updated
	updateFields := []string{}
	if value != nil {
		updateValues["value"] = *value
		updateFields = append(updateFields, "value = $value")
	}
	if unit != nil {
		updateValues["unit"] = *unit
		updateFields = append(updateFields, "unit = $unit")
	}

	// write to the query
	query := fmt.Sprintf("UPDATE $id SET %s WHERE user_id=$user_id;", strings.Join(updateFields, ", "))
	// send the UPDATE query
	result, err := database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// unmarshal results
	results, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no user associated heath metric object found")
	}

	response := &model.UpdateHealthMetricResponse{
		MetricID: results[0].ID,
		Message:  "Health metric updated successfully",
	}

	return response, nil
}

// DeleteHealthMetric is the resolver for the deleteHealthMetric field.
func (r *mutationResolver) DeleteHealthMetric(ctx context.Context, metricID string) (*model.DeleteHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check the legality of the metric id
	if !utils.MatchID(metricID, "health_metric") {
		return nil, fmt.Errorf("illegal health metric id")
	}

	// Execute the query, returning the entry before it is deleted
	result, err := database.DB.Query(
		`DELETE $id WHERE user_id=$user_id RETURN BEFORE;`,
		map[string]interface{}{
			"id":      metricID,
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshal the results, and check if the entry existed before DELETE
	results, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no health metric object found")
	}

	// create response
	response := &model.DeleteHealthMetricResponse{
		Message: fmt.Sprintf("Health metric %s of type %s deleted successfully", results[0].ID, results[0].MetricType),
	}

	return response, nil
}

// CreateDietPlan is the resolver for the createDietPlan field.
func (r *mutationResolver) CreateDietPlan(ctx context.Context, mealType string, foodItems string, calories float64) (*model.CreateDietPlanResponse, error) {
	panic(fmt.Errorf("not implemented: CreateDietPlan - createDietPlan"))
}

// UpdateDietPlan is the resolver for the updateDietPlan field.
func (r *mutationResolver) UpdateDietPlan(ctx context.Context, planID string, mealType *string, foodItems *string, calories *float64) (*model.UpdateDietPlanResponse, error) {
	panic(fmt.Errorf("not implemented: UpdateDietPlan - updateDietPlan"))
}

// DeleteDietPlan is the resolver for the deleteDietPlan field.
func (r *mutationResolver) DeleteDietPlan(ctx context.Context, planID string) (*model.DeleteDietPlanResponse, error) {
	panic(fmt.Errorf("not implemented: DeleteDietPlan - deleteDietPlan"))
}

// AddMedicalRecord is the resolver for the addMedicalRecord field.
func (r *mutationResolver) AddMedicalRecord(ctx context.Context, recordType string, content string) (*model.AddMedicalRecordResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 插入新的医疗记录
	result, err := database.DB.Query(
		`CREATE ONLY medical_record:ulid() 
        SET recordType=$recordType,
            content=$content,
            createdAt=time::now(),
            updatedAt=time::now();`,
		map[string]interface{}{
			"recordType": recordType,
			"content":    content,
		},
	)
	if err != nil {
		return nil, err
	}

	newRecord, err := surrealdb.SmartUnmarshal[model.MedicalRecordDetail](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.AddMedicalRecordResponse{
		RecordID: newRecord.RecordID,
		Message:  "Medical record added successfully",
	}

	return response, nil
}

// GetMedicalRecords is the resolver for the getMedicalRecords field.
func (r *mutationResolver) GetMedicalRecords(ctx context.Context) ([]*model.MedicalRecordDetail, error) {
	// panic(fmt.Errorf("not implemented: GetMedicalRecords - getMedicalRecords"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 查询所有医疗记录
	result, err := database.DB.Query(`SELECT * FROM medical_record;`, nil)
	if err != nil {
		return nil, err
	}

	records, err := surrealdb.SmartUnmarshal[[]*model.MedicalRecordDetail](result, nil)
	if err != nil {
		return nil, err
	}

	return records, nil
}

// UpdateMedicalRecord is the resolver for the updateMedicalRecord field.
func (r *mutationResolver) UpdateMedicalRecord(ctx context.Context, recordID string, recordType *string, content *string) (*model.UpdateMedicalRecordResponse, error) {
	//panic(fmt.Errorf("not implemented: UpdateMedicalRecord - updateMedicalRecord"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 构建更新查询
	query := `UPDATE medical_record SET updatedAt=time::now()`
	params := map[string]interface{}{}

	if recordType != nil {
		query += `, recordType=$recordType`
		params["recordType"] = *recordType
	}
	if content != nil {
		query += `, content=$content`
		params["content"] = *content
	}
	query += ` WHERE id=$id;`
	params["id"] = recordID

	// 执行更新
	_, err := database.DB.Query(query, params)
	if err != nil {
		return nil, err
	}

	response := &model.UpdateMedicalRecordResponse{
		RecordID: recordID,
		Message:  "Medical record updated successfully",
	}

	return response, nil
}

// DeleteMedicalRecord is the resolver for the deleteMedicalRecord field.
func (r *mutationResolver) DeleteMedicalRecord(ctx context.Context, recordID string) (*model.DeleteMedicalRecordResponse, error) {
	//panic(fmt.Errorf("not implemented: DeleteMedicalRecord - deleteMedicalRecord"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 执行删除
	_, err := database.DB.Query(`DELETE FROM medical_record WHERE id=$id;`, map[string]interface{}{
		"id": recordID,
	})
	if err != nil {
		return nil, err
	}

	response := &model.DeleteMedicalRecordResponse{
		Message: "Medical record deleted successfully",
	}

	return response, nil
}

// AddFamilyMember is the resolver for the addFamilyMember field.
func (r *mutationResolver) AddFamilyMember(ctx context.Context, relatedUserID string, relationship string, accessLevel string) (*model.AddFamilyMemberResponse, error) {
	//panic(fmt.Errorf("not implemented: AddFamilyMember - addFamilyMember"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 插入新的家庭成员
	result, err := database.DB.Query(
		`CREATE ONLY family_member:ulid() 
        SET relatedUserID=$relatedUserID,
            relationship=$relationship,
            accessLevel=$accessLevel,
            createdAt=time::now();`,
		map[string]interface{}{
			"relatedUserID": relatedUserID,
			"relationship":  relationship,
			"accessLevel":   accessLevel,
		},
	)
	if err != nil {
		return nil, err
	}

	newMember, err := surrealdb.SmartUnmarshal[model.FamilyMemberDetail](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.AddFamilyMemberResponse{
		MemberID: newMember.MemberID,
		Message:  "Family member added successfully",
	}

	return response, nil
}

// UpdateFamilyMember is the resolver for the updateFamilyMember field.
func (r *mutationResolver) UpdateFamilyMember(ctx context.Context, memberID string, relationship *string, accessLevel *string) (*model.UpdateFamilyMemberResponse, error) {
	//panic(fmt.Errorf("not implemented: UpdateFamilyMember - updateFamilyMember"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 构建更新查询
	query := `UPDATE family_member SET updatedAt=time::now()`
	params := map[string]interface{}{}

	if relationship != nil {
		query += `, relationship=$relationship`
		params["relationship"] = *relationship
	}
	if accessLevel != nil {
		query += `, accessLevel=$accessLevel`
		params["accessLevel"] = *accessLevel
	}
	query += ` WHERE id=$id;`
	params["id"] = memberID

	// 执行更新
	_, err := database.DB.Query(query, params)
	if err != nil {
		return nil, err
	}

	response := &model.UpdateFamilyMemberResponse{
		MemberID: memberID,
		Message:  "Family member updated successfully",
	}

	return response, nil
}

// DeleteFamilyMember is the resolver for the deleteFamilyMember field.
func (r *mutationResolver) DeleteFamilyMember(ctx context.Context, memberID string) (*model.DeleteFamilyMemberResponse, error) {
	//panic(fmt.Errorf("not implemented: DeleteFamilyMember - deleteFamilyMember"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 执行删除
	_, err := database.DB.Query(`DELETE FROM family_member WHERE id=$id;`, map[string]interface{}{
		"id": memberID,
	})
	if err != nil {
		return nil, err
	}

	response := &model.DeleteFamilyMemberResponse{
		Message: "Family member deleted successfully",
	}

	return response, nil
}

// CreateAchievementBadge is the resolver for the createAchievementBadge field.
func (r *mutationResolver) CreateAchievementBadge(ctx context.Context, name string, description string, iconURL string) (*model.CreateAchievementBadgeResponse, error) {
	//panic(fmt.Errorf("not implemented: CreateAchievementBadge - createAchievementBadge"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 插入新的成就徽章
	result, err := database.DB.Query(
		`CREATE ONLY achievement_badge:ulid() 
        SET name=$name,
            description=$description,
            iconUrl=$iconUrl,
            createdAt=time::now();`,
		map[string]interface{}{
			"name":        name,
			"description": description,
			"iconUrl":     iconURL,
		},
	)
	if err != nil {
		return nil, err
	}

	newBadge, err := surrealdb.SmartUnmarshal[model.AchievementBadgeDetail](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.CreateAchievementBadgeResponse{
		BadgeID: newBadge.BadgeID,
		Message: "Achievement badge created successfully",
	}

	return response, nil
}

// AwardAchievement is the resolver for the awardAchievement field.
func (r *mutationResolver) AwardAchievement(ctx context.Context, badgeID string) (*model.AwardAchievementResponse, error) {
	//panic(fmt.Errorf("not implemented: AwardAchievement - awardAchievement"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 颁发成就徽章
	result, err := database.DB.Query(
		`CREATE ONLY user_achievement:ulid() 
        SET badgeID=$badgeID,
            earnedAt=time::now(),
            createdAt=time::now();`,
		map[string]interface{}{
			"badgeID": badgeID,
		},
	)
	if err != nil {
		return nil, err
	}

	newUserAchievement, err := surrealdb.SmartUnmarshal[model.UserAchievementDetail](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.AwardAchievementResponse{
		UserAchievementID: newUserAchievement.UserAchievementID,
		Message:           "Achievement awarded successfully",
	}

	return response, nil
}

// GetHealthRiskAssessment is the resolver for the getHealthRiskAssessment field.
func (r *queryResolver) GetHealthRiskAssessment(ctx context.Context) (*model.HealthRiskAssessmentDetailResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 查询最新的健康风险评估（假设根据创建时间或其他条件进行排序）
	result, err := database.DB.Query(`SELECT * FROM health_risk_assessment ORDER BY createdAt DESC LIMIT 1;`, nil)
	if err != nil {
		return nil, err
	}

	assessment, err := surrealdb.SmartUnmarshal[model.HealthRiskAssessmentDetailResponse](result, nil)
	if err != nil {
		return nil, err
	}

	return &assessment, nil
}

// GetMedications is the resolver for the getMedications field.
func (r *queryResolver) GetMedications(ctx context.Context) ([]*model.MedicationDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// query for all the medications associated with the user
	result, err := database.DB.Query(
		`SELECT * FROM medication WHERE user_id = $user_id;`,
		map[string]interface{}{
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	medications, err := surrealdb.SmartUnmarshal[[]model.Medication](result, nil)
	if err != nil {
		return nil, err
	}

	// loop through the medications, convert them into MedicationDetails, then return the converted list and nil
	var medicationDetails []*model.MedicationDetail
	for _, med := range medications {
		medicationDetail := &model.MedicationDetail{
			MedicationID: med.ID,
			Name:         med.Name,
			Dosage:       med.Dosage,
			Unit:         med.Unit,
			Frequency:    med.Frequency,
			Inventory:    med.Inventory,
		}
		medicationDetails = append(medicationDetails, medicationDetail)
	}

	return medicationDetails, nil
}

// GetMedicationReminders is the resolver for the getMedicationReminders field.
func (r *queryResolver) GetMedicationReminders(ctx context.Context) ([]*model.MedicationReminderDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// get all the medication reminders for the user
	result, err := database.DB.Query(
		`SELECT * FROM medication_reminder WHERE user_id = $user_id;`,
		map[string]interface{}{
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	reminders, err := surrealdb.SmartUnmarshal[[]model.MedicationReminder](result, nil)
	if err != nil {
		return nil, err
	}

	// loop through the reminders, convert them into MedicationReminderDetails, then return the converted list and nil
	var reminderDetails []*model.MedicationReminderDetail
	for _, rem := range reminders {
		reminderDetail := &model.MedicationReminderDetail{
			ReminderID:   rem.ID,
			MedicationID: rem.MedicationID,
			ReminderTime: rem.ReminderTime,
			IsTaken:      rem.IsTaken,
		}
		reminderDetails = append(reminderDetails, reminderDetail)
	}

	return reminderDetails, nil
}

// GetHealthMetrics is the resolver for the getHealthMetrics field.
func (r *queryResolver) GetHealthMetrics(ctx context.Context, startDate *string, endDate *string, metricType *string) ([]*model.HealthMetricDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// get all the health metric entries that is associated with the user
	result, err := database.DB.Query(
		`SELECT * FROM health_metric WHERE user_id = $user_id;`,
		map[string]interface{}{
			"user_id": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshal results into Go objects
	metrics, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}

	// loop through the metrics, convert them into HealthMetricDetail, then return the converted list and nil
	var metricDetails []*model.HealthMetricDetail
	for _, metric := range metrics {
		// check that the metric is within the record time constraints
		if !((startDate != nil && metric.RecordedAt < *startDate) || (endDate != nil && metric.RecordedAt > *endDate)) {
			metricDetail := &model.HealthMetricDetail{
				MetricID:   metric.ID,
				MetricType: metric.MetricType,
				Value:      metric.Value,
				RecordedAt: metric.RecordedAt,
				Unit:       metric.Unit,
			}
			metricDetails = append(metricDetails, metricDetail)
		}
	}

	return metricDetails, nil
}

// GetDietPlans is the resolver for the getDietPlans field.
func (r *queryResolver) GetDietPlans(ctx context.Context) ([]*model.DietPlanDetail, error) {
	panic(fmt.Errorf("not implemented: GetDietPlans - getDietPlans"))
}

// GetFamilyMembers is the resolver for the getFamilyMembers field.
func (r *queryResolver) GetFamilyMembers(ctx context.Context) ([]*model.FamilyMemberDetail, error) {
	panic(fmt.Errorf("not implemented: GetFamilyMembers - getFamilyMembers"))
}

// GetAchievementBadges is the resolver for the getAchievementBadges field.
func (r *queryResolver) GetAchievementBadges(ctx context.Context) ([]*model.AchievementBadgeDetail, error) {
	panic(fmt.Errorf("not implemented: GetAchievementBadges - getAchievementBadges"))
}

// GetUserAchievements is the resolver for the getUserAchievements field.
func (r *queryResolver) GetUserAchievements(ctx context.Context) ([]*model.UserAchievementDetail, error) {
	panic(fmt.Errorf("not implemented: GetUserAchievements - getUserAchievements"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
