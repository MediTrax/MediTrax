package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.55

import (
	"context"
	"fmt"
	"meditrax/graph/database"
	middlewares "meditrax/graph/middleware"
	"meditrax/graph/model"
	"meditrax/graph/utils"
	"strings"
	"time"

	surrealdb "github.com/surrealdb/surrealdb.go"
)

// AddHealthMetric is the resolver for the addHealthMetric field.
func (r *mutationResolver) AddHealthMetric(ctx context.Context, metricType string, value float64, unit string, recordedAt time.Time) (*model.AddHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check that there isn't already a metric entry for the user with the same type and record time
	result, err := database.DB.Query(
		`SELECT * FROM health_metric WHERE userId=$userId AND recordedAt=<datetime>$recordedAt AND metricType=$metricType;`,
		map[string]interface{}{
			"userId":     user.ID,
			"recordedAt": recordedAt,
			"metricType": metricType,
		},
	)
	if err != nil {
		return nil, err
	}
	metrics, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(metrics) > 0 {
		return nil, fmt.Errorf("health metric with the same type and same recordAt time already exists")
	}

	// create new HealthMetric record
	result, err = database.DB.Query(
		`CREATE ONLY health_metric:ulid()
		SET
		userId=$userId,
		metricType=$metricType,
		value=$value,
		unit=$unit,
		recordedAt=<datetime>$recordedAt,
		createdAt=<datetime>$now;
		`,
		map[string]interface{}{
			"userId":     user.ID,
			"metricType": metricType,
			"value":      value,
			"unit":       unit,
			"recordedAt": recordedAt,
			"now":        time.Now().UTC(),
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshall the returned results
	newMetric, err := surrealdb.SmartUnmarshal[model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	response := &model.AddHealthMetricResponse{
		MetricID: newMetric.ID,
		Message:  "new health metric added successfully",
	}

	return response, nil
}

// UpdateHealthMetric is the resolver for the updateHealthMetric field.
func (r *mutationResolver) UpdateHealthMetric(ctx context.Context, metricID string, value *float64, unit *string, recordedAt *time.Time) (*model.UpdateHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check legality of the health metric id
	if !utils.MatchID(metricID, "health_metric") {
		return nil, fmt.Errorf("illegal health metric id")
	}

	result, err := database.DB.Query(
		`SELECT * FROM ONLY $metricId WHERE userId=$userId;`,
		map[string]interface{}{
			"metricId": metricID,
			"userId":   user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	original, err := surrealdb.SmartUnmarshal[model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}

	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": metricID, "userId": user.ID}

	var changeLog []utils.ChangeLog

	// Prepare the fields to be updated
	updateFields := []string{}
	if value != nil {
		updateValues["value"] = *value
		updateFields = append(updateFields, "value = $value")
		change := utils.ChangeLog{
			Field: "value",
			From:  fmt.Sprintf("%f", original.Value),
			To:    fmt.Sprintf("%f", *value),
		}
		changeLog = append(changeLog, change)
	}
	if unit != nil {
		updateValues["unit"] = *unit
		updateFields = append(updateFields, "unit = $unit")
		change := utils.ChangeLog{
			Field: "unit",
			From:  original.Unit,
			To:    *unit,
		}
		changeLog = append(changeLog, change)
	}
	if recordedAt != nil {
		updateValues["recordedAt"] = *recordedAt
		updateFields = append(updateFields, "recordedAt = <datetime>$recordedAt")
		change := utils.ChangeLog{
			Field: "recordedAt",
			From:  original.RecordedAt.Format("2006-01-02T15:04:05.000"),
			To:    (*recordedAt).Format("2006-01-02T15:04:05.000"),
		}
		changeLog = append(changeLog, change)
	}

	// write to the query
	query := fmt.Sprintf("UPDATE $id SET %s WHERE userId=$userId;", strings.Join(updateFields, ", "))
	// send the UPDATE query
	result, err = database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// unmarshal results
	results, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no user associated heath metric object found")
	}

	// add to activity log
	err = utils.AddActivityLogs(user.ID, "updateHealthMetric", "user updated specs of a health metric", metricID, changeLog)
	if err != nil {
		return nil, err
	}

	response := &model.UpdateHealthMetricResponse{
		MetricID: results[0].ID,
		Message:  "Health metric updated successfully",
	}

	return response, nil
}

// DeleteHealthMetric is the resolver for the deleteHealthMetric field.
func (r *mutationResolver) DeleteHealthMetric(ctx context.Context, metricID string) (*model.DeleteHealthMetricResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	// check the legality of the metric id
	if !utils.MatchID(metricID, "health_metric") {
		return nil, fmt.Errorf("illegal health metric id")
	}

	// Execute the query, returning the entry before it is deleted
	result, err := database.DB.Query(
		`DELETE $id WHERE userId=$userId RETURN BEFORE;`,
		map[string]interface{}{
			"id":     metricID,
			"userId": user.ID,
		},
	)
	if err != nil {
		return nil, err
	}

	// unmarshal the results, and check if the entry existed before DELETE
	results, err := surrealdb.SmartUnmarshal[[]model.HealthMetric](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no health metric object found")
	}

	// create response
	response := &model.DeleteHealthMetricResponse{
		Message: fmt.Sprintf("Health metric %s of type %s deleted successfully", results[0].ID, results[0].MetricType),
	}

	return response, nil
}

// AddMedicalRecord is the resolver for the addMedicalRecord field.
func (r *mutationResolver) AddMedicalRecord(ctx context.Context, recordType string, content string) (*model.AddMedicalRecordResponse, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 插入新的医疗记录
	result, err := database.DB.Query(
		`CREATE ONLY medical_record:ulid() 
        SET userId=$userId,
			recordType=$recordType,
            content=$content,
            createdAt=<datetime>$now,
            updatedAt=<datetime>$now;`,
		map[string]interface{}{
			"userId":     user.ID,
			"recordType": recordType,
			"content":    content,
			"now":        time.Now().UTC(),
		},
	)
	if err != nil {
		return nil, err
	}

	newRecord, err := surrealdb.SmartUnmarshal[model.MedicalRecord](result, nil)
	if err != nil {
		return nil, err
	}

	response := &model.AddMedicalRecordResponse{
		RecordID: newRecord.ID,
		Message:  "Medical record added successfully",
	}

	return response, nil
}

// UpdateMedicalRecord is the resolver for the updateMedicalRecord field.
func (r *mutationResolver) UpdateMedicalRecord(ctx context.Context, recordID string, recordType *string, content *string) (*model.UpdateMedicalRecordResponse, error) {
	//panic(fmt.Errorf("not implemented: UpdateMedicalRecord - updateMedicalRecord"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// check legality of the health metric id
	if !utils.MatchID(recordID, "medical_record") {
		return nil, fmt.Errorf("illegal medical record id")
	}

	result, err := database.DB.Query(
		`SELECT * FROM ONLY $recordId WHERE userId=$userId;`,
		map[string]interface{}{
			"recordId": recordID,
			"userId":   user.ID,
		},
	)
	if err != nil {
		return nil, err
	}
	original, err := surrealdb.SmartUnmarshal[model.MedicalRecord](result, nil)
	if err != nil {
		return nil, err
	}

	// Initialize a map to hold the update values
	updateValues := map[string]interface{}{"id": recordID, "userId": user.ID}

	var changeLog []utils.ChangeLog

	// Prepare the fields to be updated
	updateFields := []string{}
	if recordType != nil {
		updateValues["recordType"] = *recordType
		updateFields = append(updateFields, "recordType = $recordType")
		change := utils.ChangeLog{
			Field: "recordType",
			From:  original.RecordType,
			To:    *recordType,
		}
		changeLog = append(changeLog, change)
	}
	if content != nil {
		updateValues["content"] = *content
		updateFields = append(updateFields, "content = $content")
		change := utils.ChangeLog{
			Field: "content",
			From:  original.Content,
			To:    *content,
		}
		changeLog = append(changeLog, change)
	}

	// write to the query
	query := fmt.Sprintf("UPDATE $id SET %s WHERE userId=$userId;", strings.Join(updateFields, ", "))
	// send the UPDATE query
	result, err = database.DB.Query(query, updateValues)
	if err != nil {
		return nil, err
	}

	// unmarshal results
	results, err := surrealdb.SmartUnmarshal[[]model.MedicalRecord](result, nil)
	if err != nil {
		return nil, err
	}
	if len(results) == 0 {
		return nil, fmt.Errorf("invalid id, no user associated medical record object found")
	}

	// add to activity log
	err = utils.AddActivityLogs(user.ID, "updateMedicalRecord", "user updated specs of a medical record", recordID, changeLog)
	if err != nil {
		return nil, err
	}

	response := &model.UpdateMedicalRecordResponse{
		RecordID: results[0].ID,
		Message:  "Medical record updated successfully",
	}

	return response, nil
}

// DeleteMedicalRecord is the resolver for the deleteMedicalRecord field.
func (r *mutationResolver) DeleteMedicalRecord(ctx context.Context, recordID string) (*model.DeleteMedicalRecordResponse, error) {
	//panic(fmt.Errorf("not implemented: DeleteMedicalRecord - deleteMedicalRecord"))
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}
	// 执行删除
	_, err := database.DB.Query(`DELETE FROM medical_record WHERE id=$id;`, map[string]interface{}{
		"id": recordID,
	})
	if err != nil {
		return nil, err
	}

	response := &model.DeleteMedicalRecordResponse{
		Message: "Medical record deleted successfully",
	}

	return response, nil
}

// GetHealthMetrics is the resolver for the getHealthMetrics field.
func (r *queryResolver) GetHealthMetrics(ctx context.Context, startDate *time.Time, endDate *time.Time, metricType *string) ([]*model.HealthMetricDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	return utils.GetHealthMetrics(*user, startDate, endDate, metricType)
}

// GetMedicalRecords is the resolver for the getMedicalRecords field.
func (r *queryResolver) GetMedicalRecords(ctx context.Context) ([]*model.MedicalRecordDetail, error) {
	user := middlewares.ForContext(ctx)
	if user == nil {
		return nil, fmt.Errorf("access denied")
	}

	return utils.GetMedicalRecords(*user)
}
